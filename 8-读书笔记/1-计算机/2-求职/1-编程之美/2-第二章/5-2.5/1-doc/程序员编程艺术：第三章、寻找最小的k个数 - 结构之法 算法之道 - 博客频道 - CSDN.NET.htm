<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
    <title>程序员编程艺术：第三章、寻找最小的k个数 - 结构之法 算法之道
        - 博客频道 - CSDN.NET</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="程序员编程艺术：第三章、寻找最小的k个数作者：July。时间：二零一一年四月二十八日。致谢：litaoye， strugglever，yansha，luuillu，Sorehead，及狂想曲创作组。微博：http://weibo.com/julyweibo。出处：http://blog.csdn.net/v_JULY_v。----------------------------------前奏">
    <script src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ga.js" async="" type="text/javascript"></script><script src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/jquery.js" type="text/javascript"></script>
    <script type="text/javascript" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ad.js"></script>
        <!--new top-->
       
        <link rel="stylesheet" href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/index.css">
        <!--new top-->

    <link rel="Stylesheet" type="text/css" href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/style.css">
    <link id="RSSLink" title="RSS" type="application/rss+xml" rel="alternate" href="http://blog.csdn.net/v_JULY_v/rss/list">
    <link rel="shortcut icon" href="http://csdnimg.cn/public/favicon.ico">
    <link type="text/css" rel="stylesheet" href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/simple.css">
 

<link rel="stylesheet" href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/font-awesome.css"><link type="text/css" rel="stylesheet" href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/bdsstyle.css"><script src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/tracking.js" charset="utf-8" type="text/javascript"></script><script src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/main.js" charset="utf-8" type="text/javascript"></script><link href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/style_002.css" rel="stylesheet" type="text/css"><script src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/logger.js"></script></head>
<body><div style="position: absolute; left: -1px; bottom: -1px; z-index: 0; width: 0px; height: 0px; overflow: hidden; visibility: hidden; display: none;" id="BAIDU_DUP_fp_wrapper"><iframe style="width: 0px; height: 0px; visibility: hidden; display: none;" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/o.htm" id="BAIDU_DUP_fp_iframe"></iframe></div><iframe style="display: none;" frameborder="0"></iframe><div style="display: block;" id="bdshare_s"><iframe id="bdsIfr" style="position:absolute;display:none;z-index:9999;" frameborder="0"></iframe><div style="display: none;" id="bdshare_l"><div id="bdshare_l_c"><h6>分享到</h6><ul><li><a href="#" class="bds_mshare mshare">一键分享</a></li><li><a href="#" class="bds_qzone qqkj">QQ空间</a></li><li><a href="#" class="bds_tsina xlwb">新浪微博</a></li><li><a href="#" class="bds_bdysc bdysc">百度云收藏</a></li><li><a href="#" class="bds_renren rrw">人人网</a></li><li><a href="#" class="bds_tqq txwb">腾讯微博</a></li><li><a href="#" class="bds_bdxc bdxc">百度相册</a></li><li><a href="#" class="bds_kaixin001 kxw">开心网</a></li><li><a href="#" class="bds_tqf txpy">腾讯朋友</a></li><li><a href="#" class="bds_tieba bdtb">百度贴吧</a></li><li><a href="#" class="bds_douban db">豆瓣网</a></li><li><a href="#" class="bds_tsohu shwb">搜狐微博</a></li><li><a href="#" class="bds_bdhome bdhome">百度新首页</a></li><li><a href="#" class="bds_sqq sqq">QQ好友</a></li><li><a href="#" class="bds_thx thx">和讯微博</a></li><li><a href="#" class="bds_more">更多...</a></li></ul><p><a href="#" class="goWebsite">百度分享</a></p></div></div></div>
    
   
      <!--new top-->
    <script id="toolbar-tpl-scriptId" fixed="true" prod="blog" skin="black" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/html.js" type="text/javascript"></script><div class="csdn-toolbar csdn-toolbar-skin-black ">        <div class="container row center-block ">          <div class="col-md-3 pull-left logo clearfix"><a href="http://www.csdn.net/?ref=toolbar" title="CSDN首页" target="_blank" class="icon"></a><a title="频道首页" href="http://blog.csdn.net/?ref=toolbar_logo" target="_blank" class="img blog-icon"></a></div>          <div class="pull-right login-wrap unlogin">            <ul class="btns">              <li class="loginlink"><a href="https://passport.csdn.net/account/login?ref=toolbar" target="_top">登录&nbsp;</a>|<a target="_top" href="https://passport.csdn.net/account/register?ref=toolbar">&nbsp;注册</a></li>              <li class="search">                <div class="icon on-search-icon">                  <div class="wrap">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <form action="http://so.csdn.net/search" method="get" target="_blank">                      <input value="toolbar" name="ref" accesskey="2" type="hidden">                      <div class="border">                        <input placeholder="搜索" name="q" accesskey="2" type="text"><span class="icon-enter-sm"></span>                      </div>                    </form>                  </div>                </div>              </li>              <li class="favor">                <div class="icon on-favor-icon">                  <div class="wrap">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <div style="display:none;" class="favor-success"><span class="msg">收藏成功</span>                      <div class="btns"><span class="btn btn-primary ok">确定</span></div>                    </div>                    <div style="display:none;" class="favor-failed"><span class="icon-danger-lg"></span><span class="msg">收藏失败，请重新收藏</span>                      <div class="btns"><span class="btn btn-primary ok">确定</span></div>                    </div>                    <form role="form" class="form-horizontal favor-form">                      <div class="form-group">                        <div class="clearfix">                          <label for="input-title" class="col-sm-2 control-label">标题</label>                          <div class="col-sm-10">                            <input value="程序员编程艺术：第三章、寻找最小的k个数 - 结构之法 算法之道 - 博客频道 - CSDN.NET" id="inputTitle" placeholder="" class="title form-control" type="text">                          </div>                        </div>                        <div class="alert alert-danger"><strong></strong>标题不能为空</div>                      </div>                      <div class="form-group">                        <label for="input-url" class="col-sm-2 control-label">网址</label>                        <div class="col-sm-10">                          <input value="http://blog.csdn.net/v_JULY_v/article/details/6370650" id="input-url" placeholder="" class="url form-control" type="text">                        </div>                      </div>                      <div class="form-group">                        <label for="input-tag" class="col-sm-2 tag control-label">标签</label>                        <div class="col-sm-10">                          <input id="input-tag" class="form-control tag" type="text">                        </div>                      </div>                      <div class="form-group">                        <label for="input-description" class="description col-sm-2 control-label">摘要</label>                        <div class="col-sm-10">                          <textarea id="input-description" class="form-control description"></textarea>                        </div>                      </div>                      <div class="form-group">                        <div class="col-sm-offset-2 col-sm-10 ft">                          <div class="col-sm-4 pull-left">                            <div class="checkbox">                              <label>                                <input name="share" checked="checked" class="share" type="checkbox">公开                              </label>                            </div>                          </div>                          <div class="col-sm-8 pull-right favor-btns">                            <button type="button" class="cancel btn btn-default">取消</button>                            <button type="submit" class="submit btn btn-primary">收藏</button>                          </div>                        </div>                      </div>                    </form>                  </div>                </div>              </li>              <li class="notify">                <div style="display:none" class="number"></div>                <div style="display:none" class="icon-hasnotes-sm"></div>                <div id="header_notice_num"></div>                <div class="icon on-notify-icon">                  <div class="wrap">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <div id="note1" class="csdn_note">                      <div class="box"></div>                    <iframe src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/a.htm" allowtransparency="true" style="z-index:-1;position:absolute;top:0;left:0;width:100%;height:100%;background:transparent" frameborder="0"></iframe></div>                  </div>                </div>              </li>              <li class="ugc">                <div class="icon on-ugc-icon">                  <div class="wrap clearfix">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <dl>                      <dt><a href="http://geek.csdn.net/news/expert?ref=toolbar" target="_blank" class="p-news clearfix"><em class="icon"></em><span>分享资讯</span></a></dt>                      <dt><a href="http://share.csdn.net/slides/new?ref=toolbar" target="_blank" class="p-doc clearfix"><em class="icon"></em><span>传PPT/文档</span></a></dt>                      <dt><a href="http://bbs.csdn.net/topics/new?ref=toolbar" target="_blank" class="p-ask clearfix"><em class="icon"></em><span>提问题</span></a></dt>                      <dt><a href="http://write.blog.csdn.net/postedit?ref=toolbar" target="_blank" class="p-blog clearfix"><em class="icon"></em><span>写博客</span></a></dt>                      <dt><a href="http://u.download.csdn.net/upload?ref=toolbar" target="_blank" class="p-src clearfix"><em class="icon"></em><span>传资源</span></a></dt>                      <dt><a href="https://code.csdn.net/projects/new?ref=toolbar" target="_blank" class="c-obj clearfix"><em class="icon"></em><span>创建项目</span></a></dt>                      <dt><a href="https://code.csdn.net/snippets/new?ref=toolbar" target="_blank" class="c-code clearfix"><em class="icon"></em><span>创建代码片</span></a></dt>                    </dl>                  </div>                </div>              </li>              <li class="profile">                <div class="icon on-profile-icon"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/100x100.jpg" class="curr-icon-img">                  <div class="wrap clearfix">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <div class="bd">                      <dl class="clearfix">                        <dt class="pull-left img"><a target="_blank" href="http://my.csdn.net/?ref=toolbar" class="avatar"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/100x100.jpg"></a></dt>                        <dd class="info"><a target="_blank" href="http://my.csdn.net/?ref=toolbar" class="nickname"></a><a class="set-nick" href="https://passport.csdn.net/account/profile">设置昵称<span class="write-icon"></span></a><span class="dec"><a class="fill-dec" href="http://my.csdn.net/" target="_blank">编辑自我介绍，让更多人了解你<span class="write-icon"></span></a></span></dd>                      </dl>                    </div>                    <div class="ft clearfix"><a target="_blank" href="http://my.csdn.net/my/account/changepwd?ref=toolbar" class="pull-left"><span class="icon-cog"></span>帐号设置</a><a href="https://passport.csdn.net/account/logout?ref=toolbar" target="_top" class="pull-right "><span class="icon-signout"></span><span class="out">退出</span></a></div>                  </div>                </div>              </li>              <li class="apps">                <div class="icon on-apps-icon">                  <div class="wrap clearfix">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                  <div class="detail">                    <dl>                      <dt>                        <h5>社区</h5>                      </dt>                      <dd> <a href="http://blog.csdn.net/?ref=toolbar" target="_blank">博客</a></dd>                      <dd> <a href="http://bbs.csdn.net/?ref=toolbar" target="_blank">论坛</a></dd>                      <dd> <a href="http://download.csdn.net/?ref=toolbar" target="_blank">下载</a></dd>                      <dd><a href="http://share.csdn.net/?ref=toolbar" target="_blank">Share</a></dd>                      <dd><a href="http://geek.csdn.net/?ref=toolbar" target="_blank">极客头条</a></dd>                    </dl>                  </div>                  <div class="detail">                    <dl>                      <dt>                        <h5>服务</h5>                      </dt>                      <dd> <a href="https://code.csdn.net/?ref=toolbar" target="_blank">CODE</a></dd>                      <dd> <a href="http://hero.csdn.net/?ref=toolbar" target="_blank">英雄会</a></dd>                      <dd> <a href="http://huiyi.csdn.net/meeting?ref=toolbar" target="_blank">会议</a></dd>                      <dd> <a href="http://www.csto.com/?ref=toolbar" target="_blank">CSTO</a></dd>                    </dl>                  </div>                  <div class="detail last">                    <dl>                      <dt>                        <h5>俱乐部</h5>                      </dt>                      <dd> <a href="http://student.csdn.net/?ref=toolbar" target="_blank">高校俱乐部</a></dd>                      <dd> <a href="http://club.csdn.net/cto?ref=toolbar" target="_blank">CTO俱乐部</a></dd>                    </dl>                  </div>                </div>              </div>            </li>            </ul>          </div>        </div>    </div>
     <!--new top-->
    <div id="container">
        <div id="header">
    <div class="header">
        <div id="blog_title">
            <h2>
                <a href="http://blog.csdn.net/v_july_v">结构之法 算法之道</a></h2>
            <h3>Google或百度搜索：结构之法，进入本博客。</h3>
            <div class="clear">
            </div>
        </div>
        <div class="clear">
        </div>
    </div>
</div>
<div id="navigator">
    <div class="navigator_bg">
    </div>
    <div class="navigator">
        <ul>
                <li id="btnContents"><a href="http://blog.csdn.net/v_july_v?viewmode=contents"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_mulu'])">
                    <img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ico_list.gif">目录视图</span></a></li>
                <li id="btnView"><a href="http://blog.csdn.net/v_july_v?viewmode=list"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_zhaiyao'])">
                    <img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ico_summary.gif">摘要视图</span></a></li>
                <li id="btnRss"><a href="http://blog.csdn.net/v_july_v/rss/list"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_RSS'])">
                    <img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ico_rss.gif">订阅</span></a></li>
</ul>
    </div>
</div>
<script type="text/javascript">
    var username = "v_JULY_v";
    var _blogger = username;
    var blog_address = "http://blog.csdn.net/v_july_v";
    var static_host = "http://static.blog.csdn.net";
    var currentUserName = "";
</script>

        <div id="body">
            <div id="main">
                <div class="main">
<div class="notice tracking-ad" data-mod="popu_3"> 

<a href="http://www.csdn.net/article/2014-04-28/2819531" target="_blank">
<font color="blue">【社区之星】孔德芳：如何才能提高Java Web性能？
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://blog.csdn.net/blogdevteam/article/details/25400391" target="_blank">
<font color="red">4月推荐博文汇总 
</font></a>

</div>                    <link href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/comment1.css" type="text/css" rel="stylesheet">
<link href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/style1.css" type="text/css" rel="stylesheet">
<div id="article_details" class="details">
    <div class="article_title">   
         <span class="ico ico_type_Original"></span>


    <h1>
        <span class="link_title"><a href="http://blog.csdn.net/v_july_v/article/details/6370650">
        程序员编程艺术：第三章、寻找最小的k个数
        </a></span>
    </h1>
</div>

    <div class="article_manage">
        <span class="link_categories">
        分类：
            <a href="http://blog.csdn.net/v_JULY_v/article/category/767341" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_fenlei']);">06.MS 100' answers</a> 
            <a href="http://blog.csdn.net/v_JULY_v/article/category/823516" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_fenlei']);">13.TAOPP array</a> 
            <a href="http://blog.csdn.net/v_JULY_v/article/category/784066" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_fenlei']);">11.TAOPP（编程艺术）</a> 
        </span>
    <span class="link_postdate">2011-04-28 21:50</span>
    <span class="link_view" title="阅读次数">61410人阅读</span>
    <span class="link_comments" title="评论次数"><a href="#comments" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_pinglun'])">评论</a>(178)</span>
    <span class="link_collect"><a href="javascript:void(0);" onclick="javascript:_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_shoucang']);collectArticle('程序员编程艺术：第三章、寻找最小的k个数','6370650');return false;" title="收藏">收藏</a></span>
    <span class="link_report"><a href="#report" onclick="javascript:_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_jubao']);report(6370650,2);return false;" title="举报">举报</a></span>
    
</div>
<div class="tag2box"><a href="http://www.csdn.net/tag/%e7%bc%96%e7%a8%8b" target="_blank" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);">编程</a><a href="http://www.csdn.net/tag/%e7%ae%97%e6%b3%95" target="_blank" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);">算法</a><a href="http://www.csdn.net/tag/algorithm" target="_blank" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);">algorithm</a><a href="http://www.csdn.net/tag/pivot" target="_blank" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);">pivot</a><a href="http://www.csdn.net/tag/sorting" target="_blank" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);">sorting</a></div>

    
<div id="article_content" class="article_content">
<p style="padding-left:30px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:16px"> 程序员编程艺术：第三章、寻找最小的k个数</span></p><p>作者：July。<br>时间：二零一一年四月二十八日。<br>致谢：<span style="color:#333333">litaoye，</span> strugglever，yansha，luuillu，Sorehead，及狂想曲创作组。<br>微博：<a target="_blank" href="http://weibo.com/julyweibo"><span style="color:#002d93">http://weibo.com/julyweibo</span></a>。<br>出处：<a target="_blank" href="http://blog.csdn.net/v_JULY_v"><span style="color:#002d93">http://blog.csdn.net/v_JULY_v</span></a>。<br>----------------------------------</p><p><br><strong><span style="color:#800000"><span style="font-size:16px">前奏</span>&nbsp;</span></strong><br>&nbsp;&nbsp;&nbsp; <a target="_blank" href="http://weibo.com/julyweibo"><strong>@July_____</strong></a>：1、当年明月：“我写文章有个习惯，由于早年读了太多学究书，所以很痛恨那些故作高深的文章，其实历史本身很精彩，所有的历史都可以写得很好看，...。”2、IT技术文章，亦是如此，可以写得很通俗，很有趣，而非故作高深。希望，我可以做到。</p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp; 下面，我试图用最清晰易懂，最易令人理解的思维或方式阐述有关寻找最小的k个数这个问题（<span style="color:#333333">这几天一直在想，除了计数排序外，这题到底还有没有其它的O（n）的算法?</span> ）。希望，有任何问题，欢迎不吝指正。谢谢。</p><p><br><strong><span style="font-size:16px"><span style="color:#800000">寻找最小的k个数</span></span></strong><br>题目描述：5.查找最小的k个元素<br>题目：输入n个整数，输出其中最小的k个。<br>例如输入1，2，3，4，5，6，7和8这8个数字，则最小的4个数字为1，2，3和4。</p><p><br><strong><span style="font-size:16px"><span style="color:#800000">第一节、各种思路，各种选择</span></span></strong></p><ul><li><div style="padding-left:30px"><strong>0、</strong> &nbsp; 咱们先简单的理解，要求一个序列中最小的k个数，按照惯有的思维方式，很简单，先对这个序列从小到大排序，然后输出前面的最小的k个数即可。</div></li><li><div style="padding-left:30px"><strong>1、</strong> &nbsp; 至于选取什么的排序方法，我想你可能会第一时间想到快速排序，我们知道，快速排序平均所费时间为n*logn，然后再遍历序列中前k个元素输出，即可，总的时间复杂度为O（n*logn+k）=<strong>O（n*logn）</strong>。</div></li><li><div style="padding-left:30px"><strong>2、</strong> &nbsp; 咱们再进一步想想，题目并没有要求要查找的k个数，甚至后n-k个数是有序的，既然如此，咱们又何必对所有的n个数都进行排序列?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 
这时，咱们想到了用选择或交换排序，即遍历n个数，先把最先遍历到得k个数存入大小为k的数组之中，对这k个数，利用选择或交换排序，找到k个数中的最大
数kmax（kmax设为k个元素的数组中最大元素），用时O（k）（你应该知道，插入或选择排序查找操作需要O（k）的时间），后再继续遍历后n-k个
数，x与kmax比较：如果x&lt;kmax，则x代替kmax，并再次重新找出k个元素的数组中最大元素kmax‘（<span style="color:#3366ff">多谢kk791159796 提醒修正</span>）；如果x&gt;kmax，则不更新数组。这样，每次更新或不更新数组的所用的时间为O（k）或O（0），整趟下来，总的时间复杂度平均下来为：n*O（k）=<strong>O（n*k）</strong>。</div></li><li><div style="padding-left:30px"><strong>3、</strong>
 &nbsp; 
当然，更好的办法是维护k个元素的最大堆，原理与上述第2个方案一致，即用容量为k的最大堆存储最先遍历到的k个数，并假设它们即是最小的k个数，建堆费
时O（k）后，有k1&lt;k2&lt;...&lt;kmax（kmax设为大顶堆中最大元素）。继续遍历数列，每次遍历一个元素x，与堆顶元素比
较，x&lt;kmax，更新堆（用时logk），否则不更新堆。这样下来，总费时O（k+（n-k）*logk）=<strong>O（n*logk）</strong>。此方法得益于在堆中，查找等各项操作时间复杂度均为logk（不然，就如上述思路2所述：直接用数组也可以找出前k个小的元素，用时O（n*k））。</div></li><li><div style="padding-left:30px"><strong>4、</strong> 按编程之美第141页上解法二的所述，类似快速排序的划分方法，N个数存储在数组S中，再从数组中随机选取一个数X（<span style="color:#0000ff">随机选取枢纽元，可做到线性期望时间O（N）的复杂度，在第二节论述</span>），把数组划分为Sa和Sb俩部分，Sa&lt;=X&lt;=Sb，如果要查找的k个元素小于Sa的元素个数，则返回Sa中较小的k个元素，否则返回Sa中<span style="font-family:SimHei;">所有</span>元素+Sb中小的k-|Sa|个元素。<span style="color:#800000"><span style="color:#000000">像上述过程一样，</span>这个运用类似快速排序的partition的快速选择SELECT算法寻找最小的k个元素，在最坏情况下亦能做到O（N）的复杂度。<span style="color:#000000">不过值得一提的是，这个快速选择SELECT算法是选取数组中“中位数的中位数”作为枢纽元，而非随机选取枢纽元。</span></span></div></li><li><div style="padding-left:30px"><strong>5、</strong>&nbsp;&nbsp; RANDOMIZED-SELECT，每次都是<strong>随机选取</strong>数列中的一个元素作为主元，在0（n）的时间内找到第k小的元素，然后遍历输出前面的k个小的元素。 如果能的话，那么总的时间复杂度为线性期望时间：O（n+k）=<strong>O（n）（当k比较小时）</strong>。</div></li></ul><p style="padding-left:30px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Ok，稍后第二节中，我会具体给出RANDOMIZED-SELECT(A, p, r, 
i)的整体完整伪码。在此之前，要明确一个问题：我们通常所熟知的快速排序是以固定的第一个或最后一个元素作为主元，每次递归划分都是不均等的，最后的平
均时间复杂度为：O（n*logn）,但RANDOMIZED-SELECT与普通的快速排序不同的是，每次递归都是随机选择序列从第一个到最后一个元素
中任一一个作为主元。</p><ul><li><div style="padding-left:30px"><strong>6、&nbsp;&nbsp; </strong>线性时间的排序，即计数排序，时间复杂度虽能达到<strong>O（n）</strong>，但限制条件太多，不常用。</div></li><li><div style="padding-left:30px"><strong>7、</strong>&nbsp;&nbsp;&nbsp;<span style="color:#3366ff">updated：</span>
 huaye502在本文的评论下指出：“可以用最小堆初始化数组，然后取这个优先队列前k个值。复杂度O(n)+k*O(log 
n)”。huaye502的意思是针对整个数组序列建最小堆，建堆所用时间为O（n）（算法导论一书上第6章第6.3节已经论证，在线性时间内，能将一个
无序的数组建成一个最小堆），然后取堆中的前k个数，总的时间复杂度即为：<strong>O（n+k*logn）</strong>。</div></li></ul><blockquote><p><span style="font-size:13px">&nbsp;&nbsp;&nbsp; <span style="font-size:16px">关于上述第7点思路的继续阐述：</span>至于思路7的O（n+k*logn）是否小于上述思路3的O（n*logk），即<span style="text-decoration:underline"><strong>O（n+k*logn）?&lt; O（n*logk）</strong></span>。
粗略数学证明可参看如下第一幅图，我们可以这么解决：当k是常数，n趋向于无穷大时，求（n*logk）/（n+k*logn）的极限T，如果
T&gt;1，那么可得O（n*logk）&gt;O（n+k*logn），也就是O（n+k*logn）&lt; 
O（n*logk）。虽然这有违我们惯常的思维，然事实最终证明的确如此，这个极值T=logk&gt;1，即<span style="text-decoration:underline">采取建立n个元素的最小堆后取其前k个数的方法的复杂度</span><strong>小于</strong><span style="text-decoration:underline"><span style="color:#800000">采取</span><span style="color:#800000">常规的建立k个元素最大堆后通过比较寻找最小的k个数的方法</span></span>的复杂度。但，最重要的是，如果建立n个元素的最小堆的话，那么其空间复杂度势必为O（N），而建立k个元素的最大堆的<strong>空间复杂度</strong>为O（k）。<strong>所以，综合考虑，我们一般还是选择用建立k个元素的最大堆的方法解决此类寻找最小的k个数的问题。</strong></span></p><p><span style="font-size:13px"><strong>&nbsp; &nbsp; </strong>思路3准确的时间复杂度表述为：O（k+（n-k）*logk），思路7准确的时间复杂度表述为：O（n+k*logn），也就是如gbb21所述粗略证明：<del>要证原式k+n*logk-n-k*logn&gt;0，等价于证（logk-1）n-k*logn+k&gt;</del>，要证思路3的时间复杂度大于思路7的时间复杂度，等价于要证原式k+n*logk-klogk-n-k*logn&gt;0，即证（logk-1）n - k*logn + k - klogk &gt; 0。<del>当when n -&gt; +/inf（n趋向于正无穷大）时，logk-1-0-0&gt;0，即只要满足logk-1&gt;0即可。原式得证。即O（k+n*logk）&gt;O（n+k*logn） =&gt;<strong>O（n+k*logn）&lt; O（n*logk），</strong>与上面得到的结论一致。</del></span></p><p><span style="font-size:13px">&nbsp;&nbsp;&nbsp;
 
事实上，是建立最大堆还是建立最小堆，其实际的程序运行时间相差并不大，运行时间都在一个数量级上。因为后续，我们还专门写了个程序进行测试，即针对
1000w的数据寻找其中最小的k个数的问题，采取两种实现，一是采取常规的建立k个元素最大堆后通过比较寻找最小的k个数的方案，一是采取建立n个元素
的最小堆，然后取其前k个数的方法，发现两相比较，<span style="text-decoration:underline">运行时间实际上相差无几</span>。结果可看下面的第二幅图。</span></p><p style="padding-left:30px"><img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_13069457515yqm.jpg" height="464" width="617"><img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1306936648cbfB.jpg" height="291" width="618"></p><p style="padding-left:30px">&nbsp;&nbsp;</p></blockquote><ul><li><div style="padding-left:30px"><strong>8、</strong>&nbsp;&nbsp;&nbsp;@lingyun310：与上述思路7类似，不同的是在对元素数组原地建最小堆O(n)后，然后提取K次，<span style="text-decoration:underline"><span style="color:#333333"><strong>但是每次提取时，换到顶部的元素只需要下移顶多k次就足够了</strong></span></span>，下移次数逐次减少（<span style="color:#000000"><em><span style="color:#3366ff">而上述思路7每次提取都需要logn，所以提取k次，思路7需要k*logn。而本思路8只需要K^2</span></em></span>）。
此种方法的复杂度为O(n+k^2)。@July：对于这个O（n+k^2）的复杂度，我相当怀疑。因为据我所知，n个元素的堆，堆中任何一项操作的复杂
度皆为logn，所以按理说，lingyun310方法的复杂度应该跟下述思路8一样，也为O（n+k*logn），而非O（n+k*k）。ok，先放到
这，待时间考证<span style="color:#3366ff"><span style="color:#000000">。</span>06.02。</span></div></li></ul><p style="padding-left:30px">updated：<br>&nbsp;&nbsp; 经过和几个朋友的讨论，已经证实，上述思路7lingyun310所述的思路应该是完全可以的。下面，我来具体解释下他的这种方法。</p><p style="padding-left:30px">&nbsp;&nbsp;&nbsp;
 
我们知道，n个元素的最小堆中，可以先取出堆顶元素得到我们第1小的元素，然后把堆中最后一个元素（较大的元素）上移至堆顶，成为新的堆顶元素（取出堆顶
元素之后，把堆中下面的最后一个元素送到堆顶的过程可以参考下面的第一幅图。至于为什么是怎么做，为什么是把最后一个元素送到堆顶成为堆顶元素，而不是把
原来堆顶元素的儿子送到堆顶呢?具体原因可参考相关书籍）。</p><p style="padding-left:30px">&nbsp;&nbsp;&nbsp;
 
此时，堆的性质已经被破坏了，所以此后要调整堆。怎么调整呢?就是一般人所说的针对新的堆顶元素shiftdown，逐步下移（因为新的堆顶元素由最后一
个元素而来，比较大嘛，既然是最小堆，当然大的元素就要下沉到堆的下部了）。下沉多少步呢?即如lingyun310所说的，下沉k次就足够了。</p><p style="padding-left:30px">&nbsp;&nbsp;&nbsp;
 
下移k次之后，此时的堆顶元素已经是我们要找的第2小的元素。然后，取出这个第2小的元素（堆顶元素），再次把堆中的最后一个元素送到堆顶，又经过k-1
次下移之后（此后下移次数逐步减少，k-2，k-3,...k=0后算法中断）....，如此重复k-1趟操作，不断取出的堆顶元素即是我们要找的最小的
k个数。虽然上述算法中断后整个堆已经不是最小堆了，但是求得的k个最小元素已经满足我们题目所要求的了，就是说已经找到了最小的k个数，那么其它的咱们
不管了。</p><p style="padding-left:30px">&nbsp;&nbsp;&nbsp; <span style="text-decoration:underline">我可以再举一个形象易懂的例子。</span>你
可以想象在一个水桶中，有很多的气泡，这些气泡从上到下，总体的趋势是逐渐增大的，但却不是严格的逐次大（正好这也符合最小堆的性质）。ok，现在我们取
出第一个气泡，那这个气泡一定是水桶中所有气泡中最小的，把它取出来，然后把最下面的那个大气泡（但不一定是最大的气泡）移到最上面去，此时违反了气泡从
上到下总体上逐步变大的趋势，所以，要把这个大气泡往下沉，下沉到哪个位置呢?就是下沉k次。下沉k次后，最上面的气泡已经肯定是最小的气泡了，把他再次
取出。然后又将最下面最后的那个气泡移至最上面，移到最上面后，再次让它逐次下沉，下沉k-1次...，如此循环往复，最终取到最小的k个气泡。</p><p style="padding-left:30px">&nbsp;&nbsp;&nbsp;
 
ok，所以，上面方法所述的过程，更进一步来说，其实是第一趟调整保持第0层到第k层是最小堆，第二趟调整保持第0层到第k-1层是最小堆...，依次类
推。但这个思路只是下述思路8中正规的最小堆算法（因为它最终对全部元素都进行了调整，算法结束后，整个堆还是一个最小堆）的调优，时间复杂度
O（n+k^2）没有量级的提高，空间复杂度为O（N）也不会减少。</p><p style="padding-left:60px"><img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1307026090jxHW.jpg" height="383" width="483"></p><p style="padding-left:60px">原理理解透了，那么写代码，就不难了，完整粗略代码如下（有问题烦请批评指正）：<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_1" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" name="ZeroClipboardMovie_1" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=1&amp;width=0&amp;height=0" wmode="transparent" align="middle" height="0" width="0"></div></div></div><ol class="dp-cpp" start="1"><li class="alt"><span><span class="comment">//copyright@&nbsp;泡泡鱼</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//July、2010.06.02。</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="comment">//@lingyun310：先对元素数组原地建最小堆，O(n)。然后提取K次，但是每次提取时，</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//换到顶部的元素只需要下移顶多k次就足够了，下移次数逐次减少。此种方法的复杂度为O（n+k^2）。</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="preprocessor">#include&nbsp;&lt;stdio.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="preprocessor">#include&nbsp;&lt;stdlib.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="preprocessor">#define&nbsp;MAXLEN&nbsp;123456</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="preprocessor">#define&nbsp;K&nbsp;100</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="comment">//</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">void</span><span>&nbsp;HeapAdjust(</span><span class="datatypes">int</span><span>&nbsp;array[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;Length)&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;child,temp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(temp=array[i];2*i+1&lt;Length;i=child)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child&nbsp;=&nbsp;2*i+1;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(child&lt;Length-1&nbsp;&amp;&amp;&nbsp;array[child+1]&lt;array[child])&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child++;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(temp&gt;array[child])&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[i]=array[child];&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[child]=temp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="keyword">void</span><span>&nbsp;Swap(</span><span class="datatypes">int</span><span>*&nbsp;a,</span><span class="datatypes">int</span><span>*&nbsp;b)&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;*a=*a^*b;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;*b=*a^*b;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;*a=*a^*b;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;GetMin(</span><span class="datatypes">int</span><span>&nbsp;array[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;Length,</span><span class="datatypes">int</span><span>&nbsp;k)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;min=array[0];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;Swap(&amp;array[0],&amp;array[Length-1]);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;child,temp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;i=0,j=k-1;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(temp=array[0];&nbsp;j&gt;0&nbsp;&amp;&amp;&nbsp;2*i+1&lt;Length;&nbsp;--j,i=child)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child&nbsp;=&nbsp;2*i+1;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(child&lt;Length-1&nbsp;&amp;&amp;&nbsp;array[child+1]&lt;array[child])&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child++;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(temp&gt;array[child])&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[i]=array[child];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[child]=temp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;min;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;Kmin(</span><span class="datatypes">int</span><span>&nbsp;array[]&nbsp;,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;Length&nbsp;,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;k)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i=Length/2-1;i&gt;=0;--i)&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//初始建堆，时间复杂度为O(n)</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HeapAdjust(array,i,Length);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;j=Length;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(i=k;i&gt;0;--i,--j)&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//k次循环，每次循环的复杂度最多为k次交换，复杂度为o(k^2)</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;min=GetMin(array,j,i);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="string">"%d,"</span><span>,&nbsp;min);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;array[MAXLEN];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i=MAXLEN;i&gt;0;--i)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[MAXLEN-i]&nbsp;=&nbsp;i;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;Kmin(array,MAXLEN,K);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><textarea style="display: none;" class="cpp" cols="50" rows="15" name="code">//copyright@ 泡泡鱼
//July、2010.06.02。

//@lingyun310：先对元素数组原地建最小堆，O(n)。然后提取K次，但是每次提取时，
//换到顶部的元素只需要下移顶多k次就足够了，下移次数逐次减少。此种方法的复杂度为O（n+k^2）。
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MAXLEN 123456
#define K 100

//
void HeapAdjust(int array[], int i, int Length)
{
	int child,temp;
	for(temp=array[i];2*i+1&lt;Length;i=child)
	{
		child = 2*i+1;
		if(child&lt;Length-1 &amp;&amp; array[child+1]&lt;array[child])
			child++;
		if (temp&gt;array[child])
			array[i]=array[child];
		else
			break;
		array[child]=temp;
	}
}

void Swap(int* a,int* b)
{
	*a=*a^*b;
	*b=*a^*b;
	*a=*a^*b;
}

int GetMin(int array[], int Length,int k)
{
	int min=array[0];
	Swap(&amp;array[0],&amp;array[Length-1]);
	
	int child,temp;
	int i=0,j=k-1;
	for (temp=array[0]; j&gt;0 &amp;&amp; 2*i+1&lt;Length; --j,i=child)
	{
		child = 2*i+1;
		if(child&lt;Length-1 &amp;&amp; array[child+1]&lt;array[child])
			child++;
		if (temp&gt;array[child])
			array[i]=array[child];
		else
			break;
		array[child]=temp;
	}
	
	return min;
}

void Kmin(int array[] , int Length , int k)
{
	for(int i=Length/2-1;i&gt;=0;--i) 
		//初始建堆，时间复杂度为O(n)
		HeapAdjust(array,i,Length);
	
	int j=Length;
	for(i=k;i&gt;0;--i,--j) 
		//k次循环，每次循环的复杂度最多为k次交换，复杂度为o(k^2)
	{
		int min=GetMin(array,j,i);
		printf("%d,", min);
	}
}

int main()
{
	int array[MAXLEN];
	for(int i=MAXLEN;i&gt;0;--i)
		array[MAXLEN-i] = i;
	
	Kmin(array,MAXLEN,K);
	return 0;
}</textarea></p><blockquote><p><span style="font-size:13px">&nbsp;&nbsp;&nbsp; 在<strong>算法导论</strong>第
6章有下面这样一张图，因为开始时曾一直纠结过这个问题，“取出堆顶元素之后，把堆中下面的最后一个元素送到堆顶”。因为算法导论上下面这张图给了我一个
假象，从a）-&gt;b）中，让我误以为是取出堆顶元素之后，是把原来堆顶元素的儿子送到堆顶。而事实上不是这样的。<span style="text-decoration:underline">因为在下面的图中，16被删除后，堆中最后一个元素1代替16成为根结点，然后1下沉（注意下图所示的过程是最大堆的堆排序过程，不再是上面的最小堆了，所以小的元素当然要下移），14上移到堆顶。所以，图中小图<span style="color:#333333"><strong>图b）</strong></span>是已经在小<span style="color:#333333"><strong>图a）</strong></span>之和被调整过的最大堆了</span>，只是调整了logn次，非上面所述的k次。</span></p><p style="padding-left:90px"><span style="font-size:13px"><img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_13070295125mcW.jpg" height="366" width="417"></span></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="text-decoration:underline"><strong>ok，接下来，咱们再着重分析下上述思路4</strong></span>。或许，你不会相信上述思路4的观点，但我马上将用事实来论证我的观点。这几天，我一直在想，也一直在找资料查找类似快速排序的partition过程的分治算法（即上述在编程之美上提到的第4点思路），是否能做到O（N）的论述或证明，</p><p>&nbsp;&nbsp;&nbsp;&nbsp;
 
然找了三天，不但在算法导论上找到了RANDOMIZED-SELECT，在平均情况下为线性期望时间O（N）的论证（请参考本文第二节），还在mark
 allen weiss所著的数据结构与算法分析--c语言描述一书（还得多谢朋友sheguang提醒）中，<strong>第7章第7.7.6节（</strong><span style="color:#000000">本文下面的第4节末，也有关此问题的阐述</span><strong>）</strong>也找到了在最坏情况下，为线性时间O（N）（是的<strong>，不含期望，是最坏情况下为O（N）</strong>）的快速选择算法（<span style="color:#3366ff">此算法，本文文末，也有阐述</span>），请看下述文字（<span style="color:#0000ff">括号里的中文解释为本人添加</span>）：</p><blockquote><p>&nbsp;&nbsp;&nbsp;
 Quicksort can be modified to solve the selection problem, which we have
 seen in chapters 1 and 6. Recall that by using a priority queue, we can
 find the kth largest (or smallest) element in O(n + k log n)（即上述思路7）. 
For the special case of finding the median, this gives an O(n log n) 
algorithm.</p><p>&nbsp;&nbsp;&nbsp; Since we can sort the file in O(nlog
 n) time, one might expect to obtain a better time bound for selection. 
The algorithm we present to find the kth smallest element in a set S is 
almost identical to quicksort. In fact, the first three steps are the 
same. We will call&nbsp;&nbsp;&nbsp;&nbsp; this algorithm 
quickselect（叫做快速选择）. Let |Si| denote the number of elements in 
Si（令|Si|为Si中元素的个数）. The steps of quickselect are（<strong>快速选择，即上述编程之美一书上的，思路4，步骤如下</strong>）:</p><p>&nbsp;&nbsp;&nbsp;
 1. If |S| = 1, then k = 1 and return the elements in S as the answer. 
If a cutoff for small files is being used and |S| &lt;=CUTOFF, then sort
 S and return the kth smallest element.<br>&nbsp;&nbsp; &nbsp;2. Pick a pivot element, v (- S.（选取一个枢纽元v属于S）<br>&nbsp;&nbsp; &nbsp;3. Partition S - {v} into S1 and S2, as was done with quicksort.<br>（将集合S-{v}分割成S1和S2，就像我们在快速排序中所作的那样）</p><p>&nbsp;
 &nbsp; 4. If k &lt;= |S1|, then the kth smallest element must be in S1.
 In this case, return quickselect (S1, k). If k = 1 + |S1|, then the 
pivot is the kth smallest element and we can return it as the answer. 
Otherwise, the kth smallest element lies in S2, and it is the (k - |S1| -
 1)st smallest element in S2. We make a recursive call and return 
quickselect (S2, k - |S1| - 1).<br>（如果k&lt;=|S1|，那么第k个最小元素必然在S1中。在这种情况下，
返回quickselect（S1,k）。如果k=1+|S1|，那么枢纽元素就是第k个最小元素，即找到，直接返回它。否则，这第k个最小元素就在S2
中，即S2中的第（k-|S1|-1）（多谢<span style="color:#3366ff">王洋</span>提醒修正）个最小元素，我们递归调用并返回quickselect（S2，k-|S1|-1））。</p><p>&nbsp;&nbsp;&nbsp;
 In contrast to quicksort, quickselect makes only one recursive call 
instead of two. The worst case of quickselect is identical to that of 
quicksort and is O(n2). Intuitively, this is because quicksort's worst 
case is when one of S1 and S2 is empty; thus, quickselect（快速选择） is not 
really saving a recursive call. The average running time, however, is 
O(n)（<strong>不过，其平均运行时间为O（N）</strong>。看到了没，就是平均复杂度为O（N）这句话）. The analysis is similar to quicksort's and is left as an exercise.</p><p>&nbsp;&nbsp;&nbsp;
 The implementation of quickselect is even simpler than the abstract 
description might imply. The code to do this shown in Figure 7.16. When 
the algorithm terminates, the kth smallest element is in position k. 
This destroys the original ordering; if this is not desirable, then a 
copy must be made.&nbsp;</p></blockquote><p>并给出了代码示例：</p><p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_2" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" name="ZeroClipboardMovie_2" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=2&amp;width=0&amp;height=0" wmode="transparent" align="middle" height="0" width="0"></div></div></div><ol class="dp-cpp" start="1"><li class="alt"><span><span class="comment">//copyright@&nbsp;mark&nbsp;allen&nbsp;weiss</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//July、updated，2011.05.05凌晨.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="comment">//q_select&nbsp;places&nbsp;the&nbsp;kth&nbsp;smallest&nbsp;element&nbsp;in&nbsp;a[k]</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;q_select(&nbsp;input_type&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;k,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;left,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;right&nbsp;)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;i,&nbsp;j;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;input_type&nbsp;pivot;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(&nbsp;left&nbsp;+&nbsp;CUTOFF&nbsp;&lt;=&nbsp;right&nbsp;)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pivot&nbsp;=&nbsp;median3(&nbsp;a,&nbsp;left,&nbsp;right&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//取三数中值作为枢纽元，可以消除最坏情况而保证此算法是O（N）的。不过，这还只局限在理论意义上。</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//稍后，除了下文的第二节的随机选取枢纽元，在第四节末，您将看到另一种选取枢纽元的方法。</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=left;&nbsp;j=right-1;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(;;)&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(&nbsp;a[++i]&nbsp;&lt;&nbsp;pivot&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(&nbsp;a[--j]&nbsp;&gt;&nbsp;pivot&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(i&nbsp;&lt;&nbsp;j&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(&nbsp;&amp;a[i],&nbsp;&amp;a[j]&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(&nbsp;&amp;a[i],&nbsp;&amp;a[right-1]&nbsp;);&nbsp;<span class="comment">/*&nbsp;restore&nbsp;pivot&nbsp;*/</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(&nbsp;k&nbsp;&lt;&nbsp;i)&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q_select(&nbsp;a,&nbsp;k,&nbsp;left,&nbsp;i-1&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(&nbsp;k&nbsp;&gt;&nbsp;i&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q-select(&nbsp;a,&nbsp;k,&nbsp;i+1,&nbsp;right&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insert_sort(a,&nbsp;left,&nbsp;right&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><textarea style="display: none;" class="cpp" cols="50" rows="15" name="code">//copyright@ mark allen weiss
//July、updated，2011.05.05凌晨.

//q_select places the kth smallest element in a[k]
void q_select( input_type a[], int k, int left, int right )
{
	int i, j; 
	input_type pivot;  
	if( left + CUTOFF &lt;= right )
	{ 
		pivot = median3( a, left, right );   
		//取三数中值作为枢纽元，可以消除最坏情况而保证此算法是O（N）的。不过，这还只局限在理论意义上。
		//稍后，除了下文的第二节的随机选取枢纽元，在第四节末，您将看到另一种选取枢纽元的方法。
		
		i=left; j=right-1;  
		for(;;) 
		{  
			while( a[++i] &lt; pivot );  
			while( a[--j] &gt; pivot );  
			if (i &lt; j )  
				swap( &amp;a[i], &amp;a[j] );  
			else   
				break;   
		} 
		swap( &amp;a[i], &amp;a[right-1] ); /* restore pivot */    
		if( k &lt; i) 
			q_select( a, k, left, i-1 );  
		else  
			if( k &gt; i )  
				q-select( a, k, i+1, right );   
	}
	else  
        insert_sort(a, left, right );  
}</textarea>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>结论：</strong></p><ol><li>与快速排序相比，快速选择只做了一次递归调用而不是两次。快速选择的最坏情况和快速排序的相同，也是O（N^2），最坏情况发生在枢纽元的选取不当，以致S1，或S2中有一个序列为空。</li><li>这就好比快速排序的运行时间与划分是否对称有关，划分的好或对称，那么快速排序可达最佳的运行时间O（n*logn），划分的不好或不对称，则会有最坏的运行时间为O（N^2）。而枢纽元的选取则完全决定快速排序的partition过程是否划分对称。</li><li>快速选择也是一样，如果枢纽元的选取不当，则依然会有最坏的运行时间为O（N^2）的情况发生。那么，怎么避免这个最坏情况的发生，或者说就算是最坏情况下，亦能保证快速选择的运行时间为O（N）列?对了，关键，还是看你的枢纽元怎么选取。</li><li>像
上述程序使用三数中值作为枢纽元的方法可以使得最坏情况发生的概率几乎可以忽略不计。然而，稍后，在本文第四节末，及本文文末，您将看到：通过一种更好的
方法，如“五分化中项的中项”，或“中位数的中位数”等方法选取枢纽元，我们将能彻底保证在最坏情况下依然是线性O（N）的复杂度。</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至于编程之美上所述：从数组中随机选取一个数X，把数组划分为Sa和Sb俩部分，那么这个问题就转到了下文第二节<strong>RANDOMIZED-SELECT</strong>，以线性期望时间做选择，无论如何，编程之美上的解法二的复杂度为O（n*logk）都是有待商榷的。至于最坏情况下一种全新的，为O（N）的快速选择算法，直接<span style="color:#3366ff">跳转到本文第四节末，或文末部分吧</span>）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，为了公正起见，把编程之美第141页上的源码贴出来，由大家来评判：</p><p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_3" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" name="ZeroClipboardMovie_3" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=3&amp;width=0&amp;height=0" wmode="transparent" align="middle" height="0" width="0"></div></div></div><ol class="dp-cpp" start="1"><li class="alt"><span><span>Kbig(S,&nbsp;k):&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(k&nbsp;&lt;=&nbsp;0):&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;返回空数组</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(length&nbsp;S&nbsp;&lt;=&nbsp;k):&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;S&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Sa,&nbsp;Sb)&nbsp;=&nbsp;Partition(S)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;Kbig(Sa,&nbsp;k).Append(Kbig(Sb,&nbsp;k&nbsp;–&nbsp;length&nbsp;Sa)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>Partition(S):&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sa&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;初始化为空数组</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sb&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;初始化为空数组</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swap(s[1],&nbsp;S[Random()%length&nbsp;S])&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;随机选择一个数作为分组标准，以</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;避免特殊数据下的算法退化，也可</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;以通过对整个数据进行洗牌预处理</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;实现这个目的</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;S[1]&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;i&nbsp;in&nbsp;[2:&nbsp;length&nbsp;S]:&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S[i]&nbsp;&gt;&nbsp;p&nbsp;?&nbsp;Sa.Append(S[i])&nbsp;:&nbsp;Sb.Append(S[i])&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;将p加入较小的组，可以避免分组失败，也使分组</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;更均匀，提高效率&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>length&nbsp;Sa&nbsp;&lt;&nbsp;length&nbsp;Sb&nbsp;?&nbsp;Sa.Append(p)&nbsp;:&nbsp;Sb.Append(p)&nbsp;&nbsp;</span></li><li class=""><span><span class="keyword">return</span><span>&nbsp;(Sa,&nbsp;Sb)&nbsp;&nbsp;</span></span></li></ol></div><textarea style="display: none;" class="cpp" cols="50" rows="15" name="code">Kbig(S, k):
     if(k &lt;= 0):
          return [] 	// 返回空数组
     if(length S &lt;= k):
          return S
     (Sa, Sb) = Partition(S)
     return Kbig(Sa, k).Append(Kbig(Sb, k – length Sa)

Partition(S):
     Sa = []        	// 初始化为空数组
     Sb = []       	// 初始化为空数组
     Swap(s[1], S[Random()%length S])	// 随机选择一个数作为分组标准，以
                     	// 避免特殊数据下的算法退化，也可
                    	// 以通过对整个数据进行洗牌预处理
                    	// 实现这个目的
     p = S[1]
     for i in [2: length S]:
         S[i] &gt; p ? Sa.Append(S[i]) : Sb.Append(S[i])
                           	// 将p加入较小的组，可以避免分组失败，也使分组
                          	// 更均匀，提高效率 
length Sa &lt; length Sb ? Sa.Append(p) : Sb.Append(p)
return (Sa, Sb)</textarea> </p><p>&nbsp;&nbsp;&nbsp;&nbsp; 
你已经看到，它是随机选取数组中的任一元素为枢纽的，这就是本文下面的第二节RANDOMIZED-SELECT的问题了，只是要修正的是，此算法的平均
时间复杂度为线性期望O（N）的时间。而，稍后在本文的第四节或本文文末，您还将会看到此问题的进一步阐述（SELECT算法，即快速选择算法），此
SELECT算法能保证即使在最坏情况下，依然是线性O（N）的复杂度。</p><blockquote><p><strong>updated：</strong></p><p>&nbsp;&nbsp; <strong>1、</strong>为了照顾手中没编程之美这本书的friends，我拍了张照片，现贴于下供参考（提醒：<strong>1、</strong>书上为寻找最大的k个数，而我们面对的问题是寻找最小的k个数，两种形式，一个本质（该修改的地方，上文已经全部修改）。<strong>2、</strong>书中描述与上文思路4并无原理性出入，不过，勿被图中记的笔记所误导，因为之前也曾被书中的这个n*logk复杂度所误导过。ok，相信，看完本文后，你不会再有此疑惑）：</p><p style="padding-left:30px"><img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1304746434c9w4.jpg" height="329" width="440"></p><p>&nbsp;&nbsp;&nbsp; <strong>2、</strong>同
时，在编程之美原书上此节的解法五的开头提到，“上面类似快速排序的方法平均时间复杂度是线性的”，我想上面的类似快速排序的方法，应该是指解法（即如上
所述的类似快速排序partition过程的方法），但解法二得出的平均时间复杂度却为O（N*logk），明摆着前后矛盾（参见下图）。</p><p style="padding-left:30px"><img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1304746434MqG3.jpg" height="330" width="440"></p><p>&nbsp;&nbsp;&nbsp; <strong>3、</strong>此文创作后的几天，已把本人的意见反馈给邹欣等人，下面是编程之美bop1的改版修订地址的页面截图（本人也在参加其改版修订的工作），下面的文字是我的记录（同时，本人声明，<strong>此狂想曲系列文章系我个人独立创作</strong>，与其它的事不相干）：</p><p style="padding-left:30px"><img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_13047464336TD6.jpg" height="240" width="440"></p></blockquote><p><br><span style="font-size:16px"><strong><span style="color:#800000">第二节、Randomized-Select，线性期望时间</span></strong></span><br>&nbsp;&nbsp; 下面是RANDOMIZED-SELECT(A, p, r)完整伪码（来自算法导论），我给了注释，或许能给你点启示。在下结论之前，我还需要很多的时间去思量，以确保结论之完整与正确。</p><blockquote><p style="padding-left:30px">PARTITION(A, p, r)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#333333">&nbsp;</span> <span style="color:#3366ff"><span style="color:#333333">//partition过程 p为第一个数，r为最后一个数</span><br></span>1&nbsp; x ← A[r]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#333333">//以最后一个元素作为主元</span><br>2&nbsp; i ← p - 1<br>3&nbsp; for j ← p to r - 1<br>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do if A[j] ≤ x<br>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then i ← i + 1<br>6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 exchange A[i] &lt;-&gt; A[j]<br>7&nbsp; exchange A[i + 1] &lt;-&gt; A[r]<br>8&nbsp; return i + 1</p><p style="padding-left:30px">RANDOMIZED-PARTITION(A, p, r)&nbsp;<span style="color:#3366ff">&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#333333"> //随机快排的partition过程</span></span><br>1&nbsp; i ← RANDOM(p, r)&nbsp;<span style="color:#3366ff">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#333333">&nbsp;&nbsp;&nbsp;&nbsp; //i&nbsp; 随机取p到r中个一个值</span></span><br>2&nbsp;
 exchange A[r] &lt;-&gt; 
A[i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#333333">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</span><span style="color:#008000"><span style="color:#333333">//以随机的 i作为主元</span><br></span>3&nbsp; return PARTITION(A, p, r)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#333333">&nbsp;//调用上述原来的partition过程</span></p><p style="padding-left:30px">RANDOMIZED-SELECT(A, p, r, i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#333333">&nbsp;//以线性时间做选择，目的是返回数组A[p..r]中的第i 小的元素</span><br>1&nbsp; if p = r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<span style="color:#333333">&nbsp; //p=r，序列中只有一个元素</span> <br>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then return A[p]<br>3&nbsp; q ← RANDOMIZED-PARTITION(A, p, r)&nbsp;&nbsp;<span style="color:#008000"> <span style="color:#333333">//随机选取的元素q作为主元</span> </span><br>4&nbsp;
 k ← q - p + 
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 <span style="color:#333333">//k表示子数组 A[p…q]内的元素个数，处于划分低区的元素个数加上一个主元元素</span><br>5&nbsp;
 if i == 
k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 <span style="color:#333333">&nbsp;//检查要查找的i 等于子数组中A[p....q]中的元素个数k</span><br>6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then return A[q]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#333333">//则直接返回A[q]</span> <br>7&nbsp; else if i &lt; k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then return RANDOMIZED-SELECT(A, p, q - 1, i)&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<span style="color:#333333">//得到的k 大于要查找的i 的大小，则递归到低区间A[p，q-1]中去查找</span><br>9&nbsp; else return RANDOMIZED-SELECT(A, q + 1, r, i - k)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#333333">&nbsp;//得到的k 小于要查找的i 的大小，则递归到高区间A[q+1，r]中去查找。</span> &nbsp;</p></blockquote><p>&nbsp;&nbsp;&nbsp; 写此文的目的，在于起一个抛砖引玉的作用。希望，能引起你的重视及好的思路，直到有个彻底明白的结果。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:16px">updated：</span><span style="color:#000000">算法导论原英文版有关于RANDOMIZED-SELECT(A, p, r)为O（n）的证明。为了一个彻底明白的阐述，我现将其原文的证明自个再翻译加工后，阐述如下：</span></p><blockquote><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:24pt" align="left"><span style="font-family:宋体"><span style="font-size:13px">此<span lang="EN-US">RANDOMIZED-SELECT</span>最坏情况下时间复杂度为<span lang="EN-US">Θ(<em>n</em><sup>2</sup>),</span>即使是要选择最小元素也是如此，因为在划分时可能极不走运，总是按余下元素中的最大元素进行划分，而划分操作需要<span lang="EN-US">O</span>（<span lang="EN-US">n</span>）的时间。</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:24pt" align="left"><span style="font-family:宋体"><span style="font-size:13px">然而此算法的平均情况性能极好，因为它是随机化的，故没有哪一种特别的输入会导致其最坏情况的发生。</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:24pt" align="left"><span style="font-family:宋体"><span style="font-size:13px">算法导论上，针对此<span style="color:#800000"><span lang="EN-US">RANDOMIZED-SELECT</span>算法平均时间复杂度为<span lang="EN-US">O</span>（<span lang="EN-US">n</span>）的证明</span>，引用如下，或许，能给你我多点的启示（<span style="color:#333333">本来想直接引用第二版中文版的翻译文字，但在中英文对照阅读的情况下，发现第二版中文版的翻译实在不怎么样，所以，得自己一个一个字的敲，最终敲完<strong>修正</strong>如下</span>），分4步证明：</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:24pt" align="left"><span style="font-family:宋体"><span style="font-size:13px"><strong>1、</strong>当<span lang="EN-US">RANDOMIZED-SELECT</span>作用于一个含有<span lang="EN-US">n</span>个元素的输入数组<em><span lang="EN-US">A</span></em><span lang="EN-US">[<em>p</em> ..<em>r</em>]</span>上时，所需时间是一个随机变量，记为<em><span lang="EN-US">T</span></em><span lang="EN-US">(<em>n</em>),</span>我们可以这样得到线性期望值<span lang="EN-US">E [<em>T</em>(<em>n</em>)]</span>的下界：程序<span lang="EN-US">RANDOMIZED-PARTITION</span>会以等同的可能性返回数组中任何一个元素为主元，因此，对于每一个<span lang="EN-US">k</span>，（<span lang="EN-US">1 ≤<em>k</em> ≤<em>n</em></span><em>）</em><span lang="EN-US">,</span>子数组<em><span lang="EN-US">A</span></em><span lang="EN-US">[<em>p</em> ..<em>q</em>]</span>有<span lang="EN-US">k</span>个元素，它们全部小于或等于主元元素的概率为<span lang="EN-US">1/<em>n</em>.</span>对<em><span lang="EN-US">k</span></em><span lang="EN-US"> = 1, 2,...,<em>n</em>,</span>我们定指示器<em><span lang="EN-US">X<sub>k</sub></span></em><span lang="EN-US"></span>，为：</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:48pt" align="left"><span style="font-size:13px"><em><span style="font-family:宋体">X<sub>k</sub></span></em><span style="font-family:宋体"> = I{</span><span style="font-family:宋体">子数组<em><span lang="EN-US">A</span></em><span lang="EN-US">[<em>p</em> ..<em>q</em>]</span>恰有<span lang="EN-US">k</span>个元素<span lang="EN-US">} ,</span></span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:30pt" align="left"><span style="font-family:宋体"><span style="font-size:13px">我们假定元素的值不同，因此有</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:48pt" align="left"><span style="font-family:宋体"><span style="font-size:13px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp;E[Xk]=1/n</strong></span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:24pt" align="left"><span style="font-family:宋体"><span style="font-size:13px">当调用<span lang="EN-US">RANDOMIZED-SELECT</span>并且选择<em><span lang="EN-US">A</span></em><span lang="EN-US">[<em>q</em>]</span>作为主元元素的时候<span lang="EN-US">,</span>我们事先不知道是否会立即找到我们所想要的第<span lang="EN-US">i</span>小的元素，因为，我们很有可能需要在子数组<em><span lang="EN-US">A</span></em><span lang="EN-US">[<em>p</em> ..<em>q</em> - 1], </span>或<em><span lang="EN-US">A</span></em><span lang="EN-US">[<em>q</em> + 1 ..<em>r</em>]</span>上递归继续进行寻找<span lang="EN-US">.</span>具体在哪一个子数组上递归寻找，视第<span lang="EN-US">i</span>小的元素与<em><span lang="EN-US">A</span></em><span lang="EN-US">[<em>q</em>]的</span>相对位置而定<span lang="EN-US">.</span></span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:24pt" align="left"><span style="font-family:宋体"><span style="font-size:13px"><strong>2、</strong>假设<em><span lang="EN-US">T</span></em><span lang="EN-US">(<em>n</em>)</span>是单调递增的，我们可以将递归所需时间的界限限定在输入数组时可能输入的所需递归调用的最大时间（此句话，原中文版的翻译也是有问题的）<span lang="EN-US">.</span>换言之<span lang="EN-US">,</span>我们断定<span lang="EN-US">,</span><strong>为得到一个上界，我们假定第<span lang="EN-US">i</span>小的元素总是在划分的较大的一边</strong>，对一个给定的<span lang="EN-US">RANDOMIZED-SELECT,</span>指示器<span lang="EN-US">Xk</span>刚好在一个<span lang="EN-US">k</span>值上取<span lang="EN-US">1</span>，在其它的<span lang="EN-US">k</span>值时，都是取<span lang="EN-US">0.</span>当<span lang="EN-US">Xk =1</span>时，可能要递归处理的俩个子数组的大小分别为<span lang="EN-US">k-1</span>，和<span lang="EN-US">n-k</span>，因此可得到递归式为</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体"><span style="font-size:13px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1304514510KbJk.jpg" height="87" width="313"></span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:24pt" align="left"><span style="font-family:宋体; font-size:12pt"><span style="font-size:13px">取期望值为：</span><span lang="EN-US"><br><span style="font-size:13px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1304514495Zgkk.jpg" height="202" width="477"><br></span></span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:24pt" align="left"><span style="font-family:宋体"><span style="font-size:13px">为了能应用等式<span style="text-decoration:underline"><span style="color:blue">(C.23)</span></span><span lang="EN-US">,</span>我们依赖于<em><span lang="EN-US">X<sub>k</sub></span></em><span lang="EN-US"></span>和<em><span lang="EN-US">T</span></em><span lang="EN-US">(max(<em>k</em> - 1,<em>n</em> - <em>k</em>))</span>是独立的随机变量（这个可以证明，证明此处略）。</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:24pt" align="left"><span style="font-family:宋体"><span style="font-size:13px"><strong>3、</strong>下面，我们来考虑下表达式<span lang="EN-US">max(<em>k</em> - 1,<em>n</em> -<em>k</em>)</span>的结果<span lang="EN-US">.</span>我们有：</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:24pt" align="left"><span style="font-family:宋体"><span style="font-size:13px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1304514480KQdT.jpg" height="37" width="267"></span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:24pt" align="left"><span style="font-size:13px"><span style="font-family:宋体">如果<span lang="EN-US">n</span>是偶数，从<em><span lang="EN-US">T</span></em><span lang="EN-US">(</span></span><span style="font-family:宋体">⌉</span><span style="font-family:宋体">)</span><span style="font-family:宋体">到<em><span lang="EN-US">T</span></em><span lang="EN-US">(<em>n</em> - 1)</span>每个项在总和中刚好出现俩次，<em><span lang="EN-US">T</span></em><span lang="EN-US">(</span></span><span style="font-family:宋体">⌋</span><span style="font-family:宋体">)</span><span style="font-family:宋体">出现一次。因此，有</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体"><span style="font-size:13px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1304514464wJWv.jpg" height="44" width="232"></span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:24pt" align="left"><span style="font-family:宋体"><span style="font-size:13px">我们可以用替换法来解上面的递归式。假设对满足这个递归式初始条件的某个常数<span lang="EN-US">c</span>，有<em><span lang="EN-US">T</span></em><span lang="EN-US">(<em>n</em>) ≤<em>cn</em></span>。我们假设对于小于某个常数c（稍后再来说明如何选取这个常数）的<span lang="EN-US">n，有</span><em><span lang="EN-US">T</span></em><span lang="EN-US">(<em>n</em>) =<em>O</em>(1)。 </span><span style="color:#333333">同时，还要选择一个常数a，使得对于所有的<span lang="EN-US">n&gt;0</span>，由上式中<em><span lang="EN-US">O</span></em><span lang="EN-US">(<em>n</em>)</span>项<span lang="EN-US">(用来描述这个算法的运行时间中非递归的部分)</span>所描述的函数，可由<span lang="EN-US">an</span>从上方限界得到</span>（这里，原中文版的翻译的确是有点含糊）。利用这个归纳假设，可以得到：</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:24pt" align="left"><span style="font-family:宋体"><span style="font-size:13px">（此段原中文版翻译有点问题，上述文字已经修正过来，对应的此段原英文为：We solve the recurrence by substitution. Assume that<span class="emphasis" style="font-style: italic;">T</span>(<span class="emphasis" style="font-style: italic;">n</span>)<span class="unicode">≤</span><span class="emphasis" style="font-style: italic;">cn</span> for some constant <span class="emphasis" style="font-style: italic;">c</span> that satisfies the initial conditions of the recurrence. We assume that<span class="emphasis" style="font-style: italic;">T</span>(<span class="emphasis" style="font-style: italic;">n</span>) =<span class="emphasis" style="font-style: italic;">O</span>(1) for<span class="emphasis" style="font-style: italic;">n</span> less than some constant; we shall pick this constant later. We also pick a constant<span class="emphasis" style="font-style: italic;">a</span> such that the function described by the<span class="emphasis" style="font-style: italic;">O</span>(<span class="emphasis" style="font-style: italic;">n</span>) term above (which describes the non-recursive component of the running time of the algorithm) is bounded from above by<span class="emphasis" style="font-style: italic;">an</span> for all<span class="emphasis" style="font-style: italic;">n</span><span class="unicode">&gt;</span> 0. Using this inductive hypothesis, we have）</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体"><span style="font-size:13px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1304514449xkKN.jpg" height="369" width="354"></span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:24pt" align="left"><span style="font-family:宋体"><span style="font-size:13px"><strong>4、</strong>为了完成证明，还需要证明对足够大的n，上面最后一个表达式最大为<span lang="EN-US">cn</span>，即要证明：<em><span lang="EN-US">cn</span></em><span lang="EN-US">/4 -<em>c</em>/2 -<em>an</em> ≥ 0.</span>如果在俩边加上<em><span lang="EN-US">c</span></em><span lang="EN-US">/2</span>，并且提取因子<span lang="EN-US">n</span>，就可以得到<em><span lang="EN-US">n</span></em><span lang="EN-US">(<em>c</em>/4 -<em>a</em>) ≥<em>c</em>/2.</span>只要我们选择的常数<span lang="EN-US">c</span>能满足<em><span lang="EN-US">c</span></em><span lang="EN-US">/4 -<em>a</em> &gt; 0, i.e.,</span>即<em><span lang="EN-US">c</span></em><span lang="EN-US"> &gt; 4<em>a</em>,</span>我们就可以将俩边同时除以<em><span lang="EN-US">c</span></em><span lang="EN-US">/4 -<em>a</em>, </span>最终得到：</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体"><span style="font-size:13px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1304514433gm66.jpg" height="36" width="147"></span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; text-indent:24pt" align="left"><span style="font-family:宋体"><span style="font-size:13px">综上，如果假设对<em><span lang="EN-US">n</span></em><span lang="EN-US"> &lt; 2<em>c</em>/(<em>c</em> -4<em>a</em>),</span>有<em><span lang="EN-US">T</span></em><span lang="EN-US">(<em>n</em>) =<em>O</em>(1)</span>，我们就能得到<span lang="EN-US"><strong>E[<em>T</em>(<em>n</em>)]</strong></span><span lang="EN-US"><strong> =<em>O</em>(<em>n</em>)</strong>。</span>所以，最终我们可以得出这样的结论，并确认无疑：<strong>在平均情况下，任何顺序统计量（特别是中位数）都可以在线性时间内得到。</strong></span></span></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-size:16px">&nbsp;结论：</span>&nbsp;如你所见，RANDOMIZED-SELECT有线性期望时间O（N）的复杂度，但此RANDOMIZED-SELECT算法在最坏情况下有O（N^2）的复杂度。所以，我们得找出一种在最坏情况下也为线性时间的算法。稍后，<strong>在本文的第四节末，及本文文末部分</strong>，你将看到一种在<strong><span style="color:#333333">最坏情况下是线性时间O（N）的复杂度的快速选择SELECT算法</span>。</strong></p><p>&nbsp;</p><p><span style="font-size:16px"><strong><span style="color:#800000">第三节、各执己见，百家争鸣</span></strong></span></p><p><span style="font-size:16px"><span style="color:#3366ff">updated</span> </span>：本文昨晚发布后，现在朋友们之间，主要有以下几种观点（在彻底弄清之前，最好不要下结论）：</p><p>&nbsp;</p><ol><li><div style="padding-left:30px"><span style="color:#333333"><strong>luuillu</strong></span>：
我不认为随机快排比直接快排的时间复杂度小。使用快排处理数据前，我们是不知道数据的排列规律的，因此一般情况下，被处理的数据本来就是一组随机数据，对
于随机数据再多进行一次随机化处理，数据仍然保持随机性，对排序没有更好的效果。&nbsp;&nbsp; 
对一组数据采用随选主元的方法，在极端的情况下，也可能出现每次选出的主元恰好是从大到小排列的，此时时间复杂度为O（n^2）.当然这个概率极低。随机
选主元的好处在于，由于在现实中常常需要把一些数据保存为有序数据，因此，快速排序碰到有序数据的概率就会高一些，使用随机快排可以提高对这些数据的处理
效率。这个概率虽然高一些，但仍属于特殊情况，不影响一般情况的时间复杂度。我觉得楼主上面提到的的思路4和思路5的时间复杂度是一样的。</div></li><li><div style="padding-left:30px">571楼 得分：0 Sorehead 回复于：2011-03-09 16:29:58<br>关于第五题：<br><strong>Sorehead：</strong> 这两天我总结了一下，有以下方法可以实现：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1、第一次遍历取出最小的元素，第二次遍历取出第二小的元素，依次直到第k次遍历取出第k小的元素。这种方法最简单，时间复杂度是O(k*n)。看上去效率很差，但当k很小的时候可能是最快的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 
2、对这n个元素进行排序，然后取出前k个数据即可，可以采用比较普遍的堆排序或者快速排序，时间复杂度是O(n*logn)。这种方法有着很大的弊端，
题目并没有要求这最小的k个数是排好序的，更没有要求对其它数据进行排序，对这些数据进行排序某种程度上来讲完全是一种浪费。而且当k=1时，时间复杂度
依然是O(n*logn)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3、可以把快速排序改进一下，应该和楼主的kth_elem一样，这样的好处是不用对所有数据都进行排序。平均时间复杂度应该是O(n*logk)。（<span style="color:#3366ff">在本文</span><span style="color:#3366ff">最后一节，你或将看到，复杂度可能应该为O（n）</span>）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 
4、使用我开始讲到的平衡二叉树或红黑树，树只用来保存k个数据即可，这样遍历所有数据只需要一次。时间复杂度为O(n*logk)。后来我发现这个思路
其实可以再改进，使用堆排序中的堆，堆中元素数量为k，这样<strong>堆</strong>中最大元素就是头节点，<strong>遍历所有数据时比较次数更少</strong>，当然时间复杂度并没有变化。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 
5、使用计数排序的方法，创建一个数组，以元素值为该数组下标，数组的值为该元素在数组中出现的次数。这样遍历一次就可以得到这个数组，然后查询这个数组
就可以得到答案了。时间复杂度为O(n)。如果元素值没有重复的，还可以使用位图方式。这种方式有一定局限性，元素必须是正整数，并且取值范围不能太大，
否则就造成极大的空间浪费，同时时间复杂度也未必就是O(n)了。当然可以再次改进，使用一种比较合适的哈希算法来代替元素值直接作为数组下标。</div></li><li><div style="padding-left:30px"><span style="color:#333333"><strong>litaoye</strong></span>：
按照算法导论上所说的，最坏情况下线性时间找第k大的数。证明一下：把数组中的元素，5个分为1组排序，排序需要进行7次比较(2^7 &gt; 
5!)，这样需要1.4 * 
n次比较，可以完成所有组的排序。取所有组的中位数，形成一个新的数组，有n/5个元素，5个分为1组排序，重复上面的操作，直到只剩下小于5个元素，找
出中位数。根据等比数列求和公式，求出整个过程的比较次数：7/5 + 7/25 + 7/125 +...... = 7/4，用7/4 * 
n次比较可以找出中位数的中位数M。能够证明，整个数组中&gt;=M的数超过3*n / 10 - 6，&lt;=M的数超过3*n / 10 - 
6。以M为基准，执行上面的PARTITION，每次至少可以淘汰3*n / 10 - 6，约等于3/10 * n个数，也就是说是用(7/4 + 
1) * n次比较之后，最坏情况下可以让数据量变为原来的7/10，同样根据等比数列求和公式，<strong>可以算出最坏情况下找出第k大的数需要的比较次数，1 + 7/10 + 49/100 + .... = 10/3, 10/3 * 11/4 * n = 110/12 * n，也就是说整个过程是O(n)的，尽管隐含的常数比较大</strong> 。</div></li></ol><p><span style="font-size:16px">&nbsp;总结：</span> </p><p><span style="font-size:16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>关于RANDOMIZED-SELECT(A, q + 1, r, i - k)，期望运行时间为O（n）已经没有疑问了，更严格的论证在上面的第二节也已经给出来了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 ok，现在，咱们剩下的问题是，除了此RANDOMIZED-SELECT(A, q + 1, r, i - 
k)方法（实用价值并不大）和计数排序，都可以做到O（n）之外，还有类似快速排序的partition过程，是否也能做到O（n）?</p><p>&nbsp;</p><p><strong><span style="color:#800000"><span style="font-size:16px">第四节、类似partition过程，最坏亦能做到O（n）?</span></span></strong></p><p>&nbsp;&nbsp;&nbsp;我想，经过上面的各路好汉的思路轰炸，您的头脑和思维肯定有所混乱了。ok，下面，我尽量以通俗易懂的方式来继续阐述咱们的问题。上面第三节的总结提出了一个问题，即<strong>类似快速排序的partition过程，是否也能做到O（n）?</strong></p><p><strong>&nbsp;&nbsp;&nbsp;</strong> 我们说对n个数进行排序，快速排序的平均时间复杂度为O（n*logn），这个n*logn的时间复杂度是如何得来的列?</p><p>&nbsp;&nbsp; 经过之前我的有关快速排序的三篇文章，相信您已经明了了以下过程：快速排序每次选取一个主元X，依据这个主元X，每次把整个序列划分为A，B俩个部分，且有Ax&lt;X&lt;Bx。</p><p>&nbsp;&nbsp;
 假如我们每次划分总是产生9:1 
的划分，那么，快速排序运行时间的递归式为：T（n）=T（9n/10）+T（n/10）+cn。形成的递归树，（注：最后同样能推出
T（n）=n*logn，即如下图中，每一层的代价为cn，共有logn层（深度），所以，最后的时间复杂度为O（n）*logn）如下：</p><p><img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1294142896fU88.jpg" height="267" width="420"></p><p>&nbsp;&nbsp;&nbsp; 而我们知道，如果我们每次划分都是平衡的，即每次都划分为均等的两部分元素（对应上图，第一层1/2,1/2，，第二层1/4，1/4.....），那么，此时快速排序的运行时间的递归式为：</p><p>&nbsp;&nbsp;&nbsp; T (n) ≤ 2T (n/2) + Θ(n) ,同样，可推导出：T (n) = O(n lg n). </p><p>&nbsp;&nbsp;&nbsp; 这就是快速排序的平均时间复杂度的由来。</p><p>&nbsp;&nbsp;&nbsp;
 
那么，咱们要面对的问题是什么，要寻找n个数的序列中前k个元素。如何找列?假设咱们首先第一次对n个数运用快速排序的partition过程划分，主元
为Xm，此刻找到的主元元素Xm肯定为序列中第m小的元素，此后，分为三种情况：<br>&nbsp;&nbsp;&nbsp; 1、如果m=k，即返回的主元即为我们要找的第k小的元素，那么直接返回主元Xm即可，然后直接输出Xm前面的m-1个元素，这m个元素，即为所求的前k个最小的元素。<br>&nbsp;&nbsp;&nbsp; 2、如果m&gt;k，那么接下来要到低区间A[0....m-1]中寻找，丢掉高区间；<br>&nbsp;&nbsp;&nbsp; 3、如果m&lt;k，那么接下来要到高区间A[m+1...n-1]中寻找，丢掉低区间。</p><p>&nbsp;&nbsp;&nbsp; <strong>当m一直&gt;k的时候</strong>，好说，区间总是被不断的均分为俩个区间（理想情况），那么最后的时间复杂度如luuillu所说，T(n)=n + T(n/2) = n + n/2 + n/4 + n/8 + ...+1 . 式中一共logn项。可得出：T（n）为O（n）。<br>&nbsp;&nbsp;&nbsp; <strong>但当m&lt;k的时候</strong>，
上述情况，就不好说了。正如luuillu所述：当m&lt;k，那么接下来要到高区间A[m+1...n-1]中寻找,新区间的长度为n-m-1, 
需要寻找 k-m个数。此时可令：k=k-m, m=n-m-1, 递归调用原算法处理，本次执行次数为 m,当m减到1算法停止<span style="color:#3366ff">（当m&lt;k 时 ,k=m-k.这个判断过程实际上相当于对m取模运算，即：k=k%m;</span><strong>）。</strong><br>&nbsp;&nbsp;&nbsp; 最终在高区间找到的k-m个数，加上在低区间的k个数，即可找到最小的k个数，是否也能得出T（n）=O（n），则还有待验证（<span style="color:#800000">本文已经全面更新，所有的论证，都已经给出，确认无误的是：类似快速排序的partition过程，明确的可以做到O（N））<span style="color:#000000">。&nbsp;</span></span></p><p>&nbsp;</p><p>&nbsp;Ok，如果在评论里回复，有诸多不便，欢迎到此帖子上回复：<a target="_blank" href="http://topic.csdn.net/u/20101126/10/b4f12a00-6280-492f-b785-cb6835a63dc9_9.html"><strong>微软100题维护地址</strong></a>，我会随时追踪这个帖子。谢谢。<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_4" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" name="ZeroClipboardMovie_4" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=4&amp;width=0&amp;height=0" wmode="transparent" align="middle" height="0" width="0"></div></div></div><ol class="dp-cpp" start="1"><li class="alt"><span><span class="comment">//求取无序数组中第K个数，本程序枢纽元的选取有问题，不作推荐。&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//copyright@&nbsp;飞羽&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//July、yansha，updated，2011.05.18。&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="preprocessor">#include&nbsp;&lt;iostream&gt;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="preprocessor">#include&nbsp;&lt;time.h&gt;&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">using</span><span>&nbsp;</span><span class="keyword">namespace</span><span>&nbsp;std;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;kth_elem(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;low,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;high,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;k)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;pivot&nbsp;=&nbsp;a[low];&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//这个程序之所以做不到O（N）的最最重要的原因，就在于这个枢纽元的选取。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//而这个程序直接选取数组中第一个元素作为枢纽元，是做不到平均时间复杂度为&nbsp;O（N）的。</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//要&nbsp;做到，就必须&nbsp;把上面选取枢纽元的&nbsp;代码改掉，要么是随机选择数组中某一元素作为枢纽元，能达到线性期望的时间</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//要么是选取数组中中位数的中位数作为枢纽元，保证最坏情况下，依然为线性O（N）的平均时间复杂度。</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;low_temp&nbsp;=&nbsp;low;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;high_temp&nbsp;=&nbsp;high;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(low&nbsp;&lt;&nbsp;high)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(low&nbsp;&lt;&nbsp;high&nbsp;&amp;&amp;&nbsp;a[high]&nbsp;&gt;=&nbsp;pivot)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--high;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[low]&nbsp;=&nbsp;a[high];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(low&nbsp;&lt;&nbsp;high&nbsp;&amp;&amp;&nbsp;a[low]&nbsp;&lt;&nbsp;pivot)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++low;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[high]&nbsp;=&nbsp;a[low];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;a[low]&nbsp;=&nbsp;pivot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//以下就是主要思想中所述的内容&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(low&nbsp;==&nbsp;k&nbsp;-&nbsp;1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;a[low];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>(low&nbsp;&gt;&nbsp;k&nbsp;-&nbsp;1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;kth_elem(a,&nbsp;low_temp,&nbsp;low&nbsp;-&nbsp;1,&nbsp;k);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;kth_elem(a,&nbsp;low&nbsp;+&nbsp;1,&nbsp;high_temp,&nbsp;k);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;&nbsp;</span><span class="comment">//以后尽量不再用随机产生的数组进行测试，没多大必要。</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;num&nbsp;=&nbsp;5000;&nbsp;num&nbsp;&lt;&nbsp;50000001;&nbsp;num&nbsp;*=&nbsp;10)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;*array&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;</span><span class="datatypes">int</span><span>[num];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;j&nbsp;=&nbsp;num&nbsp;/&nbsp;10;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;acc&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;k&nbsp;=&nbsp;1;&nbsp;k&nbsp;&lt;=&nbsp;num;&nbsp;k&nbsp;+=&nbsp;j)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;随机生成数据</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;srand(unsigned(time(0)));&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;num;&nbsp;i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[i]&nbsp;=&nbsp;rand()&nbsp;*&nbsp;RAND_MAX&nbsp;+&nbsp;rand();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//”如果数组本身就是利用随机化产生的话，那么选择其中任何一个元素作为枢轴都可以看作等价于随机选择枢轴，</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//（虽然这不叫随机选择枢纽）”，这句话，是完全不成立的，是错误的。</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//“因为你总是选择&nbsp;随机数组中第一个元素&nbsp;作为枢纽元，不是&nbsp;随机选择枢纽元”</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//相当于把上面这句话中前面的&nbsp;“随机”&nbsp;两字去掉，就是：</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//因为&nbsp;你总是选择数组中第一个元素作为枢纽元，不是&nbsp;随机选择枢纽元。</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//所以，这个程序，始终做不到平均时间复杂度为O（N）。</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//随机数组和给定一个非有序而随机手动输入的数组，是一个道理。稍后，还将就程序的运行结果继续解释这个问题。</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//July、updated，2011.05.18。</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;计算一次查找所需的时钟周期数</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">clock_t</span><span>&nbsp;start&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;data&nbsp;=&nbsp;kth_elem(array,&nbsp;0,&nbsp;num&nbsp;-&nbsp;1,&nbsp;k);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">clock_t</span><span>&nbsp;end&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc&nbsp;+=&nbsp;(end&nbsp;-&nbsp;start);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;<span class="string">"The&nbsp;average&nbsp;time&nbsp;of&nbsp;searching&nbsp;a&nbsp;date&nbsp;in&nbsp;the&nbsp;array&nbsp;size&nbsp;of&nbsp;"</span><span>&nbsp;&lt;&lt;&nbsp;num&nbsp;&lt;&lt;&nbsp;</span><span class="string">"&nbsp;is&nbsp;"</span><span>&nbsp;&lt;&lt;&nbsp;acc&nbsp;/&nbsp;10&nbsp;&lt;&lt;&nbsp;endl;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li></ol></div><textarea style="display: none;" class="cpp" cols="50" rows="15" name="code">//
求取无序数组中第K个数，本程序枢纽元的选取有问题，不作推荐。  
//copyright@ 飞羽 
//July、yansha，updated，2011.05.18。   
#include &lt;iostream&gt;  
#include &lt;time.h&gt; 
using namespace std;   

int kth_elem(int a[], int low, int high, int k)   
{   
    int pivot = a[low];  
    //这个程序之所以做不到O（N）的最最重要的原因，就在于这个枢纽元的选取。         
	//而这个程序直接选取数组中第一个元素作为枢纽元，是做不到平均时间复杂度为 O（N）的。
	
	//要 做到，就必须 把上面选取枢纽元的 代码改掉，要么是随机选择数组中某一元素作为枢纽元，能达到线性期望的时间
	//要么是选取数组中中位数的中位数作为枢纽元，保证最坏情况下，依然为线性O（N）的平均时间复杂度。
    int low_temp = low;   
    int high_temp = high;   
    while(low &lt; high)   
    {   
        while(low &lt; high &amp;&amp; a[high] &gt;= pivot)     
            --high;   
        a[low] = a[high];   
        while(low &lt; high &amp;&amp; a[low] &lt; pivot)   
            ++low;   
        a[high] = a[low];   
    }   
    a[low] = pivot;   
	
    //以下就是主要思想中所述的内容   
    if(low == k - 1)    
        return a[low];   
    else if(low &gt; k - 1)    
        return kth_elem(a, low_temp, low - 1, k);   
    else    
        return kth_elem(a, low + 1, high_temp, k);   
}   

int main()   //以后尽量不再用随机产生的数组进行测试，没多大必要。
{
	for (int num = 5000; num &lt; 50000001; num *= 10)
	{
		int *array = new int[num];
		
		int j = num / 10;
		int acc = 0;
		for (int k = 1; k &lt;= num; k += j)
		{
			// 随机生成数据
			srand(unsigned(time(0)));
			for(int i = 0; i &lt; num; i++)   
				array[i] = rand() * RAND_MAX + rand();    
			//”如果数组本身就是利用随机化产生的话，那么选择其中任何一个元素作为枢轴都可以看作等价于随机选择枢轴，
			//（虽然这不叫随机选择枢纽）”，这句话，是完全不成立的，是错误的。
			
			//“因为你总是选择 随机数组中第一个元素 作为枢纽元，不是 随机选择枢纽元”
			//相当于把上面这句话中前面的 “随机” 两字去掉，就是：
			//因为 你总是选择数组中第一个元素作为枢纽元，不是 随机选择枢纽元。
			//所以，这个程序，始终做不到平均时间复杂度为O（N）。
			
			//随机数组和给定一个非有序而随机手动输入的数组，是一个道理。稍后，还将就程序的运行结果继续解释这个问题。
			//July、updated，2011.05.18。
			
			// 计算一次查找所需的时钟周期数
			clock_t start = clock();
			int data = kth_elem(array, 0, num - 1, k);
			clock_t end = clock();
			acc += (end - start);
		}
		cout &lt;&lt; "The average time of searching a date in the array size 
of " &lt;&lt; num &lt;&lt; " is " &lt;&lt; acc / 10 &lt;&lt; endl;
	}
    return 0;   
}  </textarea>&nbsp;关于上述程序的更多阐述，请参考此文<a target="_blank" href="http://blog.csdn.net/v_JULY_v/archive/2011/05/08/6403777.aspx"><strong>第三章续、Top K算法问题的实现</strong></a>中，第一节有关实现三的说明。</p><p>&nbsp; <span style="font-size:16px">updated：</span></p><blockquote><p>&nbsp;&nbsp; 近日，再次在Mark Allen Weiss的数据结构与算法分析一书上，第10章，第10.2.3节看到了关于此分治算法的应用，平均时间复杂度为O（N）的阐述与证明，可能本文之前的叙述将因此而改写（<span style="color:#3366ff">July、updated，2011.05.05</span>）：</p><p>&nbsp;
 &nbsp;The selection problem requires us to find the kth smallest 
element in a list S of n elements（要求我们找出含N个元素的表S中的第k个最小的元素）. Of 
particular interest is the special case of finding the median. This 
occurs when k = 
|-n/2-|（向上取整）.（我们对找出中间元素的特殊情况有着特别的兴趣，这种情况发生在k=|-n/2-|的时候）</p><p>&nbsp;&nbsp;&nbsp;
 In Chapters 1, 6, 7 we have seen several solutions to the selection 
problem. The solution in Chapter 7 uses a variation of quicksort and 
runs in O(n) average time（第7章中的解法，即本文上面第1节所述的思路4，用到快速排序的变体并以平均时间O（N）运行）.
 Indeed, it is described in Hoare's original paper on quicksort.</p><p>&nbsp;&nbsp;&nbsp;
 Although this algorithm runs in linear average time, it has a worst 
case of O (n2)（但它有一个O（N^2）的最快情况）. Selection can easily be solved in O(n 
log n) worst-case time by sorting the elements, but for a long time it 
was unknown whether or not selection could be accomplished in O(n) 
worst-case time. The quickselect algorithm outlined in Section 7.7.6 is 
quite efficient in practice, so this was mostly a question of 
theoretical interest.</p><p>&nbsp;&nbsp;&nbsp; Recall that the basic 
algorithm is a simple recursive strategy. Assuming that n is larger than
 the cutoff point where elements are simply sorted, an element v, known 
as the pivot, is chosen. The remaining elements are placed into two 
sets, S1 and S2. S1 contains elements that are guaranteed to be no 
larger than v, and S2 contains elements that are no smaller than v. 
Finally, if k &lt;= |S1|, then the kth smallest element in S can be 
found by recursively computing the kth smallest element in S1. If k = 
|S1| + 1, then the pivot is the kth smallest element. Otherwise, the kth
 smallest element in S is the (k - |S1| -1 )st smallest element in S2. 
The main difference between this algorithm and quicksort is that there 
is only one subproblem to solve instead of two（<strong>这个快速选择算法与快速排序之间的主要区别在于，这里求解的只有一个子问题，而不是两个子问题</strong>）。</p><p>定理10.9<br>The running time of quickselect using median-of-median-of-five partitioning is O(n)。</p><p>&nbsp;&nbsp;&nbsp;
 The basic idea is still useful. Indeed, we will see that we can use it 
to improve the expected number of comparisons that quickselect makes. To
 get a good worst case, however, the key idea is to use one more level 
of indirection. Instead of finding the median from a sample of random 
elements, we will find the median from a sample of medians.</p><p>The basic pivot selection algorithm is as follows:<br>&nbsp;&nbsp;&nbsp; 1. Arrange the n elements into |_n/5_| groups of 5 elements, ignoring the (at most four) extra elements.<br>&nbsp;&nbsp;&nbsp; 2. Find the median of each group. This gives a list M of |_n/5_| medians.<br>&nbsp;&nbsp;&nbsp; 3. Find the median of M. Return this as the pivot, v.</p><p>&nbsp;We will use the term <strong>median-of-median-of-five partitioning</strong>
 to describe the quickselect algorithm that uses the pivot selection 
rule given above. （我们将用术语“五分化中项的中项”来描述使用上面给出的枢纽元选择法的快速选择算法）。We will now 
show that median-of-median-of-five partitioning guarantees that each 
recursive subproblem is at most roughly 70 percent as large as the 
original（现在我们要证明，“五分化中项的中项”，得保证每个递归子问题的大小最多为原问题的大约70%）. We will also 
show that the pivot can be computed quickly enough to guarantee an O (n)
 running time for the entire selection algorithm（我们还要证明，<strong>对于整个选择算法，枢纽元可以足够快的算出，以确保O（N）的运行时间</strong>。看到了没，这再次佐证了我们的类似快速排序的partition过程的分治方法为O（N）的观点）。<br>&nbsp;&nbsp; ..........<br>&nbsp;&nbsp;&nbsp; 证明从略，更多，请参考Mark Allen Weiss的数据结构与算法分析--c语言描述一书上，第10章，第10.2.3节。</p></blockquote><blockquote><p><span style="font-size:16px">updated again：</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为了给读者一个彻彻底底、明明白白的论证，我还是决定把书上面的整个论证过程全程贴上来，下面，接着上面的内容，然后直接从其中文译本上截两张图来说明好了（更清晰明了）：</p><p><img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_130453823773vR.jpg" height="583" width="622"></p><p>&nbsp;</p><p><img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_13045377523hC7.jpg" height="595" width="623"></p><p>关于上图提到的定理10.8，如下图所示，至于证明，留给读者练习（可参考本文第二节关于RANDOMIZED-SELECT为线性时间的证明）：</p><p><img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1304538587sh4S.jpg" height="52" width="500"></p></blockquote><p>&nbsp;ok，第四节，有关此问题的更多论述，请参见下面的<span style="color:#3366ff">本文文末updated again部分</span>。</p><p>&nbsp;</p><p><span style="font-size:16px"><strong><span style="color:#800000">第五节、堆结构实现，处理海量数据</span></strong></span></p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp;
 
文章，可不能这么完了，咱们还得实现一种靠谱的方案，从整个文章来看，处理这个寻找最小的k个数，最好的方案是第一节中所提到的思路3：当然，更好的办法
是维护k个元素的最大堆，原理与上述第2个方案一致，即用容量为k的最大堆存储最小的k个数，此
时，k1&lt;k2&lt;...&lt;kmax（kmax设为大顶堆中最大元素）。遍历一次数列，n，每次遍历一个元素x，与堆顶元素比
较，x&lt;kmax，更新堆（用时logk），否则不更新堆。这样下来，总费时O（n*logk）。</p><p>&nbsp;&nbsp;&nbsp;
 
为什么?道理很简单，如果要处理的序列n比较小时，思路2（选择排序）的n*k的复杂度还能说得过去，但当n很大的时候列?同时，别忘了，如果选择思路
1（快速排序），还得在数组中存储n个数。当面对海量数据处理的时候列?n还能全部存放于电脑内存中么?（或许可以，或许很难）。</p><p>&nbsp;&nbsp;&nbsp; ok，相信你已经明白了我的意思，下面，给出借助堆（思路3）这个数据结构，来寻找最小的k个数的完整代码，如下：<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_5" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" name="ZeroClipboardMovie_5" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=5&amp;width=0&amp;height=0" wmode="transparent" align="middle" height="0" width="0"></div></div></div><ol class="dp-cpp" start="1"><li class="alt"><span><span class="comment">//借助堆，查找最小的k个数</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//copyright@&nbsp;yansha&nbsp;&amp;&amp;July</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//July、updated，2011.04.28。</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="preprocessor">#include&nbsp;&lt;iostream&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="preprocessor">#include&nbsp;&lt;assert.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">using</span><span>&nbsp;</span><span class="keyword">namespace</span><span>&nbsp;std;&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;MaxHeap(</span><span class="datatypes">int</span><span>&nbsp;heap[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;len);&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">/*-------------------</span>&nbsp;</span></li><li class="alt"><span><span class="comment">BUILD-MIN-HEAP(A)</span>&nbsp;</span></li><li class=""><span><span class="comment">1&nbsp;&nbsp;heap-size[A]&nbsp;←&nbsp;length[A]</span>&nbsp;</span></li><li class="alt"><span><span class="comment">2&nbsp;&nbsp;for&nbsp;i&nbsp;←&nbsp;|_length[A]/2_|&nbsp;downto&nbsp;1</span>&nbsp;</span></li><li class=""><span><span class="comment">3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do&nbsp;MAX-HEAPIFY(A,&nbsp;i)</span>&nbsp;</span></li><li class="alt"><span><span class="comment">*/</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//&nbsp;建立大根堆</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;BuildHeap(</span><span class="datatypes">int</span><span>&nbsp;heap[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;len)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(heap&nbsp;==&nbsp;NULL)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;index&nbsp;=&nbsp;len&nbsp;/&nbsp;2;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;index;&nbsp;i&nbsp;&gt;=&nbsp;1;&nbsp;i--)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxHeap(heap,&nbsp;i,&nbsp;len);&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span><span class="comment">/*----------------------------&nbsp;&nbsp;</span>&nbsp;</span></li><li class="alt"><span><span class="comment">PARENT(i)</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;&nbsp;&nbsp;return&nbsp;|_i/2_|</span>&nbsp;</span></li><li class="alt"><span><span class="comment">LEFT(i)</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;&nbsp;&nbsp;return&nbsp;2i</span>&nbsp;</span></li><li class="alt"><span><span class="comment">RIGHT(i)</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;&nbsp;&nbsp;return&nbsp;2i&nbsp;+&nbsp;1</span>&nbsp;</span></li><li class="alt"><span><span class="comment">MIN-HEAPIFY(A,&nbsp;i)</span>&nbsp;</span></li><li class=""><span><span class="comment">1&nbsp;l&nbsp;←&nbsp;LEFT(i)</span>&nbsp;</span></li><li class="alt"><span><span class="comment">2&nbsp;r&nbsp;←&nbsp;RIGHT(i)</span>&nbsp;</span></li><li class=""><span><span class="comment">3&nbsp;if&nbsp;l&nbsp;≤&nbsp;heap-size[A]&nbsp;and&nbsp;A[l]&nbsp;&lt;&nbsp;A[i]</span>&nbsp;</span></li><li class="alt"><span><span class="comment">4&nbsp;&nbsp;&nbsp;&nbsp;then&nbsp;smallest&nbsp;←&nbsp;l</span>&nbsp;</span></li><li class=""><span><span class="comment">5&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;smallest&nbsp;←&nbsp;i</span>&nbsp;</span></li><li class="alt"><span><span class="comment">6&nbsp;if&nbsp;r&nbsp;≤&nbsp;heap-size[A]&nbsp;and&nbsp;A[r]&nbsp;&lt;&nbsp;A[smallest]</span>&nbsp;</span></li><li class=""><span><span class="comment">7&nbsp;&nbsp;&nbsp;&nbsp;then&nbsp;smallest&nbsp;←&nbsp;r</span>&nbsp;</span></li><li class="alt"><span><span class="comment">8&nbsp;if&nbsp;smallest&nbsp;≠&nbsp;i</span>&nbsp;</span></li><li class=""><span><span class="comment">9&nbsp;&nbsp;&nbsp;&nbsp;then&nbsp;exchange&nbsp;A[i]&nbsp;&lt;-&gt;&nbsp;A[smallest]</span>&nbsp;</span></li><li class="alt"><span><span class="comment">10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MIN-HEAPIFY(A,&nbsp;smallest)</span>&nbsp;</span></li><li class=""><span><span class="comment">*/</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//调整大根堆</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">void</span><span>&nbsp;MaxHeap(</span><span class="datatypes">int</span><span>&nbsp;heap[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;len)&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;largeIndex&nbsp;=&nbsp;-1;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;left&nbsp;=&nbsp;i&nbsp;*&nbsp;2;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;right&nbsp;=&nbsp;i&nbsp;*&nbsp;2&nbsp;+&nbsp;1;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(left&nbsp;&lt;=&nbsp;len&nbsp;&amp;&amp;&nbsp;heap[left]&nbsp;&gt;&nbsp;heap[i])&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;largeIndex&nbsp;=&nbsp;left;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;largeIndex&nbsp;=&nbsp;i;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(right&nbsp;&lt;=&nbsp;len&nbsp;&amp;&amp;&nbsp;heap[right]&nbsp;&gt;&nbsp;heap[largeIndex])&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;largeIndex&nbsp;=&nbsp;right;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(largeIndex&nbsp;!=&nbsp;i)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(heap[i],&nbsp;heap[largeIndex]);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxHeap(heap,&nbsp;largeIndex,&nbsp;len);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;定义数组存储堆元素</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;k;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;k;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;*heap&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;</span><span class="datatypes">int</span><span>&nbsp;[k+1];&nbsp;&nbsp;&nbsp;</span><span class="comment">//注，只需申请存储k个数的数组</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">FILE</span><span>&nbsp;*fp&nbsp;=&nbsp;fopen(</span><span class="string">"data.txt"</span><span>,&nbsp;</span><span class="string">"r"</span><span>);&nbsp;&nbsp;&nbsp;</span><span class="comment">//从文件导入海量数据（便于测试，只截取了9M的数据大小）</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;assert(fp);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;=&nbsp;k;&nbsp;i++)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fscanf(fp,&nbsp;<span class="string">"%d&nbsp;"</span><span>,&nbsp;&amp;heap[i]);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;BuildHeap(heap,&nbsp;k);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//建堆</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;newData;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>&nbsp;(fscanf(fp,&nbsp;</span><span class="string">"%d"</span><span>,&nbsp;&amp;newData)&nbsp;!=&nbsp;EOF)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(newData&nbsp;&lt;&nbsp;heap[1])&nbsp;&nbsp;&nbsp;</span><span class="comment">//如果遇到比堆顶元素kmax更小的，则更新堆</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heap[1]&nbsp;=&nbsp;newData;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxHeap(heap,&nbsp;1,&nbsp;k);&nbsp;&nbsp;&nbsp;<span class="comment">//调整堆</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;j&nbsp;=&nbsp;1;&nbsp;j&nbsp;&lt;=&nbsp;k;&nbsp;j++)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;heap[j]&nbsp;&lt;&lt;&nbsp;<span class="string">"&nbsp;"</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;endl;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;fclose(fp);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><textarea style="display: none;" class="cpp" cols="50" rows="15" name="code">//借助堆，查找最小的k个数
//copyright@ yansha &amp;&amp;July
//July、updated，2011.04.28。
#include &lt;iostream&gt;
#include &lt;assert.h&gt;
using namespace std;
void MaxHeap(int heap[], int i, int len);
/*-------------------
BUILD-MIN-HEAP(A)
1  heap-size[A] ← length[A]
2  for i ← |_length[A]/2_| downto 1
3       do MAX-HEAPIFY(A, i)
*/
// 建立大根堆
void BuildHeap(int heap[], int len)
{
	if (heap == NULL)
		return;
	
	int index = len / 2;
	for (int i = index; i &gt;= 1; i--)
		MaxHeap(heap, i, len);
}
/*----------------------------	
PARENT(i)
   return |_i/2_|
LEFT(i)
   return 2i
RIGHT(i)
   return 2i + 1
MIN-HEAPIFY(A, i)
1 l ← LEFT(i)
2 r ← RIGHT(i)
3 if l ≤ heap-size[A] and A[l] &lt; A[i]
4    then smallest ← l
5    else smallest ← i
6 if r ≤ heap-size[A] and A[r] &lt; A[smallest]
7    then smallest ← r
8 if smallest ≠ i
9    then exchange A[i] &lt;-&gt; A[smallest]
10         MIN-HEAPIFY(A, smallest)
*/
//调整大根堆
void MaxHeap(int heap[], int i, int len)
{
	int largeIndex = -1;
	int left = i * 2;
	int right = i * 2 + 1;
	
	if (left &lt;= len &amp;&amp; heap[left] &gt; heap[i])
		largeIndex = left;
	else
		largeIndex = i;
	
	if (right &lt;= len &amp;&amp; heap[right] &gt; heap[largeIndex])
		largeIndex = right;
	
	if (largeIndex != i)
	{
		swap(heap[i], heap[largeIndex]);
		MaxHeap(heap, largeIndex, len);
	}
}
int main()
{
	// 定义数组存储堆元素
	int k;
	cin &gt;&gt; k;
	int *heap = new int [k+1];   //注，只需申请存储k个数的数组
	FILE *fp = fopen("data.txt", "r");   //从文件导入海量数据（便于测试，只截取了9M的数据大小）
	assert(fp);
	
	for (int i = 1; i &lt;= k; i++)
		fscanf(fp, "%d ", &amp;heap[i]);
	
	BuildHeap(heap, k);      //建堆
	
	int newData;
	while (fscanf(fp, "%d", &amp;newData) != EOF)
	{
		if (newData &lt; heap[1])   //如果遇到比堆顶元素kmax更小的，则更新堆
		{
			heap[1] = newData;
			MaxHeap(heap, 1, k);   //调整堆
		}
		
	}
	
	for (int j = 1; j &lt;= k; j++)
		cout &lt;&lt; heap[j] &lt;&lt; " ";
	cout &lt;&lt; endl;
	
	fclose(fp);
	return 0;
}</textarea> </p><p>&nbsp;&nbsp;&nbsp; 咱们用比较大量的数据文件测试一下，如这个数据文件：</p><p><img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_13040540982RLx.jpg" height="301" width="524"></p><p>&nbsp;&nbsp;&nbsp; 输入k=4，即要从这大量的数据中寻找最小的k个数，可得到运行结果，如下图所示：</p><p><img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1304054227TRm0.jpg" height="275" width="446"></p><p>至于，这4个数，到底是不是上面大量数据中最小的4个数，这个，咱们就无从验证了，非人力之所能及也。毕。</p><p>&nbsp;</p><p>&nbsp;</p><p><strong><span style="font-size:16px"><span style="color:#800000">第六节、stl之_nth_element ，逐步实现</span></span></strong></p><p>&nbsp;&nbsp;&nbsp; 以下代码摘自stl中_nth_element的实现，且逐步追踪了各项操作，其完整代码如下：</p><p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_6" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" name="ZeroClipboardMovie_6" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=6&amp;width=0&amp;height=0" wmode="transparent" align="middle" height="0" width="0"></div></div></div><ol class="dp-cpp" start="1"><li class="alt"><span><span class="comment">//_nth_element(...)的实现</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">template</span><span>&nbsp;&lt;</span><span class="keyword">class</span><span>&nbsp;RandomAccessIterator,&nbsp;</span><span class="keyword">class</span><span>&nbsp;T&gt;&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;__nth_element(RandomAccessIterator&nbsp;first,&nbsp;RandomAccessIterator&nbsp;nth,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RandomAccessIterator&nbsp;last,&nbsp;T*)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;<span class="keyword">while</span><span>&nbsp;(last&nbsp;-&nbsp;first&nbsp;&gt;&nbsp;3)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;RandomAccessIterator&nbsp;cut&nbsp;=&nbsp;__unguarded_partition&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//下面追踪__unguarded_partition</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(first,&nbsp;last,&nbsp;T(__median(*first,&nbsp;*(first&nbsp;+&nbsp;(last&nbsp;-&nbsp;first)/2),&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(last&nbsp;-&nbsp;1))));&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(cut&nbsp;&lt;=&nbsp;nth)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first&nbsp;=&nbsp;cut;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last&nbsp;=&nbsp;cut;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;__insertion_sort(first,&nbsp;last);&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//下面追踪__insertion_sort(first,&nbsp;last)</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="comment">//__unguarded_partition()的实现</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">template</span><span>&nbsp;&lt;</span><span class="keyword">class</span><span>&nbsp;RandomAccessIterator,&nbsp;</span><span class="keyword">class</span><span>&nbsp;T&gt;&nbsp;&nbsp;</span></span></li><li class="alt"><span>RandomAccessIterator&nbsp;__unguarded_partition(RandomAccessIterator&nbsp;first,&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RandomAccessIterator&nbsp;last,&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T&nbsp;pivot)&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;<span class="keyword">while</span><span>&nbsp;(</span><span class="keyword">true</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>&nbsp;(*first&nbsp;&lt;&nbsp;pivot)&nbsp;++first;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;--last;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>&nbsp;(pivot&nbsp;&lt;&nbsp;*last)&nbsp;--last;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!(first&nbsp;&lt;&nbsp;last))&nbsp;</span><span class="keyword">return</span><span>&nbsp;first;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;iter_swap(first,&nbsp;last);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;++first;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="comment">//__insertion_sort(first,&nbsp;last)的实现</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">template</span><span>&nbsp;&lt;</span><span class="keyword">class</span><span>&nbsp;RandomAccessIterator&gt;&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">void</span><span>&nbsp;__insertion_sort(RandomAccessIterator&nbsp;first,&nbsp;RandomAccessIterator&nbsp;last)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(first&nbsp;==&nbsp;last)&nbsp;</span><span class="keyword">return</span><span>;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(RandomAccessIterator&nbsp;i&nbsp;=&nbsp;first&nbsp;+&nbsp;1;&nbsp;i&nbsp;!=&nbsp;last;&nbsp;++i)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;__linear_insert(first,&nbsp;i,&nbsp;value_type(first));&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//下面追踪__linear_insert</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="comment">//_linear_insert()的实现</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">template</span><span>&nbsp;&lt;</span><span class="keyword">class</span><span>&nbsp;RandomAccessIterator,&nbsp;</span><span class="keyword">class</span><span>&nbsp;T&gt;&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">inline</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;__linear_insert(RandomAccessIterator&nbsp;first,&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RandomAccessIterator&nbsp;last,&nbsp;T*)&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;T&nbsp;value&nbsp;=&nbsp;*last;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(value&nbsp;&lt;&nbsp;*first)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;copy_backward(first,&nbsp;last,&nbsp;last&nbsp;+&nbsp;1);&nbsp;&nbsp;<span class="comment">//这个追踪，待续</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;*first&nbsp;=&nbsp;value;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;__unguarded_linear_insert(last,&nbsp;value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//最后，再追踪__unguarded_linear_insert</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="comment">//_unguarded_linear_insert()的实现</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">template</span><span>&nbsp;&lt;</span><span class="keyword">class</span><span>&nbsp;RandomAccessIterator,&nbsp;</span><span class="keyword">class</span><span>&nbsp;T&gt;&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;__unguarded_linear_insert(RandomAccessIterator&nbsp;last,&nbsp;T&nbsp;value)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;RandomAccessIterator&nbsp;next&nbsp;=&nbsp;last;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;--next;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;<span class="keyword">while</span><span>&nbsp;(value&nbsp;&lt;&nbsp;*next)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;*last&nbsp;=&nbsp;*next;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;last&nbsp;=&nbsp;next;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;--next;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;*last&nbsp;=&nbsp;value;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><textarea style="display: none;" class="cpp" cols="50" rows="15" name="code">//_nth_element(...)的实现
template &lt;class RandomAccessIterator, class T&gt;
void __nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                   RandomAccessIterator last, T*) {
  while (last - first &gt; 3) {
    RandomAccessIterator cut = __unguarded_partition    //下面追踪__unguarded_partition
      (first, last, T(__median(*first, *(first + (last - first)/2),
                               *(last - 1))));
    if (cut &lt;= nth)
      first = cut;
    else 
      last = cut;
  }
  __insertion_sort(first, last);    //下面追踪__insertion_sort(first, last)
}

//__unguarded_partition()的实现
template &lt;class RandomAccessIterator, class T&gt;
RandomAccessIterator __unguarded_partition(RandomAccessIterator first, 
                                           RandomAccessIterator last, 
                                           T pivot) {
  while (true) {
    while (*first &lt; pivot) ++first;
    --last;
    while (pivot &lt; *last) --last;
    if (!(first &lt; last)) return first;
    iter_swap(first, last);
    ++first;
  }
}  

//__insertion_sort(first, last)的实现
template &lt;class RandomAccessIterator&gt;
void __insertion_sort(RandomAccessIterator first, RandomAccessIterator last) {
  if (first == last) return; 
  for (RandomAccessIterator i = first + 1; i != last; ++i)
    __linear_insert(first, i, value_type(first));    //下面追踪__linear_insert
}

//_linear_insert()的实现
template &lt;class RandomAccessIterator, class T&gt;
inline void __linear_insert(RandomAccessIterator first, 
                            RandomAccessIterator last, T*) {
  T value = *last;
  if (value &lt; *first) {
    copy_backward(first, last, last + 1);  //这个追踪，待续
    *first = value;
  }
  else
    __unguarded_linear_insert(last, value);        //最后，再追踪__unguarded_linear_insert
}

//_unguarded_linear_insert()的实现
template &lt;class RandomAccessIterator, class T&gt;
void __unguarded_linear_insert(RandomAccessIterator last, T value) {
  RandomAccessIterator next = last;
  --next;
  while (value &lt; *next) {
    *last = *next;
    last = next;
    --next;
  }
  *last = value;
}</textarea></p><p><strong><span style="font-size:16px"><span style="color:#800000">第七节、再探Selection_algorithm，类似partition方法O（n）再次求证</span></span></strong></p><p>网友反馈：<br>&nbsp;&nbsp;&nbsp; stupidcat：用类似快排的partition的方法，只求2边中的一边，在O(N)时间得到第k大的元素v； <br>弄完之后，vector&lt;int&gt; &amp;data的前k个元素，就是最小的k个元素了。 <br>时间复杂度是O(N)，应该是最优的算法了。并给出了代码示例：<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_7" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" name="ZeroClipboardMovie_7" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=7&amp;width=0&amp;height=0" wmode="transparent" align="middle" height="0" width="0"></div></div></div><ol class="dp-cpp" start="1"><li class="alt"><span><span class="comment">//copyright@&nbsp;stupidcat</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//July、updated，2011.05.08</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;Partition(vector&lt;</span><span class="datatypes">int</span><span>&gt;&nbsp;&amp;data,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;headId,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;tailId)&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//这里，采用的是算法导论上的partition过程方法</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;posSlow&nbsp;=&nbsp;headId&nbsp;-&nbsp;1,&nbsp;posFast&nbsp;=&nbsp;headId;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//一前一后，俩个指针</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(;&nbsp;posFast&nbsp;&lt;&nbsp;tailId;&nbsp;++posFast)&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(data[posFast]&nbsp;&lt;&nbsp;data[tailId])&nbsp;&nbsp;&nbsp;</span><span class="comment">//以最后一个元素作为主元</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++posSlow;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(data[posSlow],&nbsp;data[posFast]);&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;++posSlow;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;swap(data[posSlow],&nbsp;data[tailId]);&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;posSlow;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//写的不错，命名清晰</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="keyword">void</span><span>&nbsp;FindKLeast(vector&lt;</span><span class="datatypes">int</span><span>&gt;&nbsp;&amp;data,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;headId,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;tailId,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;k)&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//寻找第k小的元素</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(headId&nbsp;&lt;&nbsp;tailId)&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;midId&nbsp;=&nbsp;Partition(data,&nbsp;headId,&nbsp;tailId);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//可惜这里，没有随机或中位数的方法选取枢纽元（主元），使得本程序思路虽对，却不达O（N）的目标</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(midId&nbsp;&gt;&nbsp;k)&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FindKLeast(data,&nbsp;headId,&nbsp;midId&nbsp;-&nbsp;1,&nbsp;k);&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//k&lt;midid，直接在低区间找</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(midId&nbsp;&lt;&nbsp;k)&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FindKLeast(data,&nbsp;midId&nbsp;+&nbsp;1,&nbsp;tailId,&nbsp;k);&nbsp;&nbsp;&nbsp;<span class="comment">//k&gt;midid，递归到高区间找</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;FindKLeastNumbers(vector&lt;</span><span class="datatypes">int</span><span>&gt;&nbsp;&amp;data,&nbsp;unsigned&nbsp;</span><span class="datatypes">int</span><span>&nbsp;k)&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;len&nbsp;=&nbsp;data.size();&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(k&nbsp;&gt;&nbsp;len)&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throw</span><span>&nbsp;</span><span class="keyword">new</span><span>&nbsp;std::exception(</span><span class="string">"Invalid&nbsp;argument!"</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;FindKLeast(data,&nbsp;0,&nbsp;len&nbsp;-&nbsp;1,&nbsp;k);&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><textarea style="display: none;" class="cpp" cols="50" rows="15" name="code">//copyright@ stupidcat
//July、updated，2011.05.08
int Partition(vector&lt;int&gt; &amp;data, int headId, int tailId)  
//这里，采用的是算法导论上的partition过程方法
{ 
    int posSlow = headId - 1, posFast = headId;    //一前一后，俩个指针
    for (; posFast &lt; tailId; ++posFast) 
    { 
        if (data[posFast] &lt; data[tailId])   //以最后一个元素作为主元
        { 
            ++posSlow; 
            swap(data[posSlow], data[posFast]); 
        } 
    } 
    ++posSlow; 
    swap(data[posSlow], data[tailId]); 
    return posSlow;    //写的不错，命名清晰
} 

void FindKLeast(vector&lt;int&gt; &amp;data, int headId, int tailId, int k)  
//寻找第k小的元素
{ 
	if (headId &lt; tailId) 
	{ 
		int midId = Partition(data, headId, tailId);    
		//可惜这里，没有随机或中位数的方法选取枢纽元（主元），使得本程序思路虽对，却不达O（N）的目标
		
		if (midId &gt; k) 
		{ 
			FindKLeast(data, headId, midId - 1, k);    //k&lt;midid，直接在低区间找
		}  
		
		else 
		{ 
			if (midId &lt; k) 
			{ 
				FindKLeast(data, midId + 1, tailId, k);   //k&gt;midid，递归到高区间找
			} 
		} 
	} 
}

void FindKLeastNumbers(vector&lt;int&gt; &amp;data, unsigned int k) 
{ 
	int len = data.size(); 
	if (k &gt; len) 
	{ 
		throw new std::exception("Invalid argument!"); 
	} 
	FindKLeast(data, 0, len - 1, k); 
}</textarea>&nbsp; 看来，这个问题，可能会因此纠缠不清了，近日，在维基百科的英文页面上，找到有关Selection_algorithm的资料，上面给出的示例代码为：<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_8" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" name="ZeroClipboardMovie_8" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=8&amp;width=0&amp;height=0" wmode="transparent" align="middle" height="0" width="0"></div></div></div><ol class="dp-cpp" start="1"><li class="alt"><span><span>function&nbsp;partition(list,&nbsp;left,&nbsp;right,&nbsp;pivotIndex)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pivotValue&nbsp;:=&nbsp;list[pivotIndex]&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;list[pivotIndex]&nbsp;and&nbsp;list[right]&nbsp;&nbsp;<span class="comment">//&nbsp;Move&nbsp;pivot&nbsp;to&nbsp;end</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storeIndex&nbsp;:=&nbsp;left&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;i&nbsp;from&nbsp;left&nbsp;to&nbsp;right&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;list[i]&nbsp;&lt;&nbsp;pivotValue&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;list[storeIndex]&nbsp;and&nbsp;list[i]&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;increment&nbsp;storeIndex&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;list[right]&nbsp;and&nbsp;list[storeIndex]&nbsp;&nbsp;<span class="comment">//&nbsp;Move&nbsp;pivot&nbsp;to&nbsp;its&nbsp;final&nbsp;place</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;storeIndex&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;function&nbsp;select(list,&nbsp;left,&nbsp;right,&nbsp;k)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;left&nbsp;=&nbsp;right&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;list[left]&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select&nbsp;pivotIndex&nbsp;between&nbsp;left&nbsp;and&nbsp;right&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pivotNewIndex&nbsp;:=&nbsp;partition(list,&nbsp;left,&nbsp;right,&nbsp;pivotIndex)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pivotDist&nbsp;:=&nbsp;pivotNewIndex&nbsp;-&nbsp;left&nbsp;+&nbsp;1&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;pivotDist&nbsp;=&nbsp;k&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;list[pivotNewIndex]&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;k&nbsp;&lt;&nbsp;pivotDist&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;select(list,&nbsp;left,&nbsp;pivotNewIndex&nbsp;-&nbsp;1,&nbsp;k)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;select(list,&nbsp;pivotNewIndex&nbsp;+&nbsp;1,&nbsp;right,&nbsp;k&nbsp;-&nbsp;pivotDist)&nbsp;&nbsp;</span></span></li></ol></div><textarea style="display: none;" class="cpp" cols="50" rows="15" name="code">function partition(list, left, right, pivotIndex)
     pivotValue := list[pivotIndex]
     swap list[pivotIndex] and list[right]  // Move pivot to end
     storeIndex := left
     for i from left to right
         if list[i] &lt; pivotValue
             swap list[storeIndex] and list[i]
             increment storeIndex
     swap list[right] and list[storeIndex]  // Move pivot to its final place
     return storeIndex

 function select(list, left, right, k)
     if left = right
         return list[left]
     select pivotIndex between left and right
     pivotNewIndex := partition(list, left, right, pivotIndex)
     pivotDist := pivotNewIndex - left + 1
     if pivotDist = k 
         return list[pivotNewIndex]
     else if k &lt; pivotDist 
         return select(list, left, pivotNewIndex - 1, k)
     else
         return select(list, pivotNewIndex + 1, right, k - pivotDist)</textarea></p><p>&nbsp;&nbsp;&nbsp; 这个算法，其实就是在本人这篇文章：<a target="_blank" href="http://blog.csdn.net/v_JULY_v/archive/2011/03/07/6228235.aspx"><strong>当今世界最受人们重视的十大经典算法</strong></a>里提到的：第三名：BFPRT 算法：</p><blockquote><p><br>A worst-case linear algorithm for the general case of selecting the kth largest element was published by Blum,<br>Floyd, Pratt, Rivest and Tarjan in their 1973 paper "Time bounds for selection", <br>sometimes called BFPRT after the last names of the authors. <br>It is based on the quickselect algorithm and is also known as the median-of-medians algorithm.</p></blockquote><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp; 同时据维基百科上指出，若能选取一个好的pivot，则此算法能达到O（n）的最佳时间复杂度。</p><blockquote><p><br>The median-calculating recursive call does not exceed worst-case linear behavior <br>because the list of medians is 20% of the size of the list, <br>while the other recursive call recurs on at most 70% of the list, making the running time<br>&nbsp;<br>T(n) ≤ T(n/5) + T(7n/10) + O(n)</p><p>The O(n) is for the partitioning work (we visited each element a constant number of times，<br>in order to form them into O(n) groups and take each median in O(1) time). <br>From this, one can then show that T(n) ≤ c*n*(1 + (9/10) + (9/10)2 + ...) = O(n).</p></blockquote><p><br>&nbsp;&nbsp;&nbsp;
 
当然，上面也提到了用堆这个数据结构，扫描一遍数组序列，建k个元素的堆O（k）的同时，调整堆（logk），然后再遍历剩下的n-k个元素，根据其与堆
顶元素的大小比较，决定是否更新堆，更新一次logk，所以，最终的时间复杂度为O（k*logk+(n-k)*logk）=O（n*logk）。</p><blockquote><p><br>Another simple method is to add each element of the list into an ordered set data structure,<br>such as a heap or self-balancing binary search tree, with at most k elements. <br>Whenever the data structure has more than k elements, we remove the largest element,<br>which can be done in O(log k) time. Each insertion operation also takes O(log k) time,<br>resulting in O(nlog k) time overall.</p></blockquote><p>&nbsp;&nbsp;&nbsp; 而如果上述类似快速排序的partition过程的BFPRT 算法成立的话，则将最大限度的优化了此寻找第k个最小元素的算法复杂度（<span style="color:#800000">经过第1节末+第二节+第4节末的updated，以及本节的论证，现最终确定，运用类似快速排序的partition算法寻找最小的k个元素能做到O（N）的复杂度，并确认无疑。<span style="color:#000000">July、updated，2011.05.05.凌晨</span></span>）。</p><p><span style="font-size:16px">updated again：</span></p><p>&nbsp;&nbsp; 为了再次佐证上述论证之不可怀疑的准确性，我再原文引用下第九章第9.3节全部内容（最坏情况线性时间的选择），如下（我酌情对之参考原中文版做了翻译，下文中括号内的中文解释，为我个人添加）：</p><blockquote><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><strong><span style="font-family:宋体"><span style="font-size:13px">9.3 Selection in worst-case linear time（最坏情况下线性时间的选择算法）</span></span></strong></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体; font-size:12pt"><span style="font-size:13px">&nbsp;&nbsp;&nbsp; We now examine a selection algorithm whose running time is<em>O</em>(<em>n</em>)
 in the worst case（现在来看，一个最坏情况运行时间为O（N）的选择算法SELECT）. Like 
RANDOMIZED-SELECT, the algorithm SELECT finds the desired element by 
recursively partitioning the input array. The idea behind the algorithm,
 however, is to<em>guarantee</em> a good split when the array is partitioned. SELECT uses the deterministic partitioning algorithm PARTITION from quicksort (see</span><a target="_blank" href="http://@msitstorec/Documents%20and%20Settings/Administrator/%E6%A1%8C%E9%9D%A2/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E5%AD%A6%E9%99%A2-%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA.Introduction.to.Algorithms,.Second.chm"><span style="font-size:13px">Section 7.1</span></a><span style="font-size:13px">),
 modified to take the element to partition around as an input 
parameter（像RANDOMIZED-SELECT一样，SELECTT通过输入数组的递归划分来找出所求元素，但是，该算法的基本思想是要保证
对数组的划分是个好的划分。SECLECT采用了取自快速排序的确定性划分算法partition，并做了修改，把划分主元元素作为其参数）.</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体"><span style="font-size:13px">&nbsp;&nbsp;&nbsp; The SELECT algorithm determines the<em>i</em>th smallest of an input array of<em>n</em> &gt; 1 elements by executing the following steps. (If<em>n</em> = 1, then SELECT merely returns its only input value as the<em>i</em>th smallest.)（算法SELECT通过执行下列步骤来确定一个有n&gt;1个元素的输入数组中的第i小的元素。（如果n=1，则SELECT返回它的唯一输入数值作为第i个最小值。））</span></span></p><ol type="1"><li class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left"><span style="font-size:13px"><span style="font-family:宋体">Divide the<em>n</em> elements of the input array into</span><span style="font-family:宋体">⌋</span></span><span style="font-family:宋体; font-size:12pt"><span style="font-size:13px"> groups of 5 elements each and at most one group made up of the remaining<em>n</em> mod 5 elements.</span><a target="_blank" name="593"></a><a target="_blank" name="IDX-190"></a><span style="font-size:13px"></span></span></li><li class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left"><span style="font-size:13px"><span style="font-family:宋体">Find the median of each of the</span><span style="font-family:宋体">⌉</span><span style="font-family:宋体">
 groups by first insertion sorting the elements of each group (of which 
there are at most 5) and then picking the median from the sorted list of
 group elements.</span></span></li><li class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left"><span style="font-size:13px"><span style="font-family:宋体">Use SELECT recursively to find the median<em>x</em> of the</span><span style="font-family:宋体">⌉</span><span style="font-family:宋体"> medians found in step 2. (If there are an even number of medians, then by our convention,<em>x</em> is the lower median.)</span></span></li><li class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left"><span style="font-family:宋体"><span style="font-size:13px">Partition the input array around the median-of-medians<em>x</em> using the modified version of PARTITION. Let<em>k</em> be one more than the number of elements on the low side of the partition, so that<em>x</em> is the<em>k</em>th smallest element and there are<em>n</em>-<em>k</em> elements on the high side of the partition.（利用修改过的partition过程，按中位数的中位数x对输入数组进行划分，让k比划低去的元素数目多1，所以，x是第k小的元素，并且有n-k个元素在划分的高区）</span></span></li><li class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left"><span style="font-family:宋体"><span style="font-size:13px">If<em>i</em> =<em>k</em>, then return<em>x</em>. Otherwise, use SELECT recursively to find the<em>i</em>th smallest element on the low side if<em>i</em> &lt;<em>k</em>, or the (<em>i</em> -<em>k</em>)th smallest element on the high side if<em>i</em> &gt;<em>k</em>.（<strong>如果要找的第i小的元素等于程序返回的k</strong>，即i=k，则返回x。否则，如果i&lt;k，则在低区递归调用SELECT以找出第i小的元素，如果i&gt;k，则在高区间找第（i-k）个最小元素）</span></span></li></ol><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left"><span style="font-family:宋体"><span style="font-size:13px"><img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1304569647o3Wf.jpg" height="217" width="645"></span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left"><span style="font-family:宋体"><span style="font-size:13px">（以上五个步骤，即本文上面的第四节末中所提到的所谓“五分化中项的中项”的方法。）</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left">&nbsp;</p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体; font-size:12pt"><span style="font-size:13px">&nbsp;&nbsp;&nbsp;
 To analyze the running time of SELECT, we first determine a lower bound
 on the number of elements that are greater than the partitioning 
element <em>x</em>. （为了分析SELECT的运行时间，先来确定大于划分主元元素x的的元素数的一个下界）</span><span style="font-size:13px">Figure 9.1</span><span style="font-size:13px"> is helpful in visualizing this bookkeeping. At least half of the medians found in step 2 are greater than</span><sup><span style="font-size:13px">[</span><a target="_blank" name="N192"></a><a target="_blank" href="http://@msitstorec/Documents%20and%20Settings/Administrator/%E6%A1%8C%E9%9D%A2/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E5%AD%A6%E9%99%A2-%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA.Introduction.to.Algorithms,.Second.chm"><span><span style="font-size:13px">1</span></span></a><span style="font-size:13px">]</span></sup><span style="font-size:13px"> the median-of-medians <em>x</em>. Thus, at least half of the </span></span><span style="font-size:13px"><span style="font-family:宋体">⌉</span></span><span style="font-family:宋体; font-size:12pt"><span style="font-size:13px"> groups</span><span style="font-size:13px">contribute 3 elements that are greater than <em>x</em>, except for the one group that has fewer than 5 elements if 5 does not divide<em>n</em> exactly, and the one group containing<em>x</em> itself. Discounting these two groups, it follows that the number of elements greater than<em>x</em> is at least：</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体; font-size:12pt"><span style="font-size:13px">&nbsp;</span></span><span style="font-family:宋体; font-size:12pt">&nbsp;&nbsp;<img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1304568936843M.jpg" height="39" width="192"></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left">&nbsp;</p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体; font-size:12pt">&nbsp;&nbsp;&nbsp;<img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1304568936hz76.jpg" height="248" width="309"><br><span style="font-size:13px">&nbsp;&nbsp;&nbsp;
 （Figure 
9.1:&nbsp;对上图的解释或称对SELECT算法的分析：n个元素由小圆圈来表示，并且每一个组占一纵列。组的中位数用白色表示，而各中位数的中
位数x也被标出。（当寻找偶数数目元素的中位数时，使用下中位数）。箭头从比较大的元素指向较小的元素，从中可以看出，在x的右边，每一个包含5个元素的
组中都有3个元素大于x，在x的左边，每一个包含5个元素的组中有3个元素小于x。大于x的元素以阴影背景表示。 ）</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体"><span style="font-size:13px">&nbsp;&nbsp;&nbsp; Similarly, the number of elements that are less than<em>x</em> is at least 3<em>n</em>/10 - 6. Thus, in the worst case, SELECT is called recursively on at most 7<em>n</em>/10 + 6 elements in step 5.</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-size:13px"><span style="font-family:宋体">&nbsp;&nbsp;&nbsp; We can now develop a recurrence for the worst-case running time<em>T</em>(<em>n</em>) of the algorithm SELECT. Steps 1, 2, and 4 take <em>O</em>(<em>n</em>) time. (Step 2 consists of<em>O</em>(<em>n</em>) calls of insertion sort on sets of size<em>O</em>(1).) Step 3 takes time<em>T</em>(</span><span style="font-family:宋体">⌉</span><span style="font-family:宋体">), and step 5 takes time at most<em>T</em>(7<em>n</em>/10+ 6), assuming that<em>T</em>
 is monotonically increasing. We make the assumption, which seems 
unmotivated at first, that any input of 140 or fewer elements requires<em>O</em>(1) time; the origin of the magic constant 140 will be clear shortly. We can therefore obtain the recurrence：</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体"><span style="font-size:13px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_13045689360lmd.jpg" height="38" width="348"></span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体"><span style="font-size:13px">&nbsp;&nbsp;&nbsp; We show that the running time is linear by substitution. More specifically, we will show that<em>T</em>(<em>n</em>) ≤<em>cn</em> for some suitably large constant <em>c</em> and all<em>n</em> &gt; 0. We begin by assuming that<em>T</em>(<em>n</em>) ≤<em>cn</em> for some suitably large constant<em>c</em> and all<em>n</em> ≤ 140; this assumption holds if<em>c</em> is large enough. We also pick a constant<em>a</em> such that the function described by the<em>O</em>(<em>n</em>) term above (which describes the non-recursive component of the running time of the algorithm) is bounded above by<em>an</em> for all<em>n</em> &gt; 0. Substituting this inductive hypothesis into the right-hand side of the recurrence yields</span></span></p><p></p><table class="MsoNormalTable   " border="0" cellpadding="0"><tbody><tr><td style="padding:0.75pt; border:rgb(240,240,240); background-color:transparent" valign="top"><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-size:13px"><em><span style="font-family:宋体">T</span></em><span style="font-family:宋体">(<em>n</em>)</span></span></p></td><td style="padding:0.75pt; border:rgb(240,240,240); background-color:transparent" valign="top"><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:center" align="center"><span style="font-family:宋体"><span style="font-size:13px">≤ </span></span></p></td><td style="padding:0.75pt; border:rgb(240,240,240); background-color:transparent" valign="top"><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-size:13px"><em><span style="font-family:宋体">c</span></em><span style="font-family:宋体"></span><span style="font-family:宋体">⌉</span><span style="font-family:宋体"> +<em>c</em>(7<em>n</em>/10 + 6) +<em>an</em> </span></span></p></td></tr><tr><td style="padding:0.75pt; border:rgb(240,240,240); background-color:transparent" valign="top"><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体"><span style="font-size:13px">&nbsp;</span></span></p></td><td style="padding:0.75pt; border:rgb(240,240,240); background-color:transparent" valign="top"><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:center" align="center"><span style="font-family:宋体"><span style="font-size:13px">≤ </span></span></p></td><td style="padding:0.75pt; border:rgb(240,240,240); background-color:transparent" valign="top"><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-size:13px"><em><span style="font-family:宋体">cn</span></em><span style="font-family:宋体">/5 +<em>c</em> + 7<em>cn</em>/10 + 6<em>c</em> +<em>an</em></span></span></p></td></tr><tr><td style="padding:0.75pt; border:rgb(240,240,240); background-color:transparent" valign="top"><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体"><span style="font-size:13px">&nbsp;</span></span></p></td><td style="padding:0.75pt; border:rgb(240,240,240); background-color:transparent" valign="top"><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:center" align="center"><span style="font-family:宋体"><span style="font-size:13px">=</span></span></p></td><td style="padding:0.75pt; border:rgb(240,240,240); background-color:transparent" valign="top"><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体"><span style="font-size:13px">9<em>cn</em>/10 + 7<em>c</em> +<em>an</em></span></span></p></td></tr><tr><td style="padding:0.75pt; border:rgb(240,240,240); background-color:transparent" valign="top"><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体"><span style="font-size:13px">&nbsp;</span></span></p></td><td style="padding:0.75pt; border:rgb(240,240,240); background-color:transparent" valign="top"><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:center" align="center"><span style="font-family:宋体"><span style="font-size:13px">=</span></span></p></td><td style="padding:0.75pt; border:rgb(240,240,240); background-color:transparent" valign="top"><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-size:13px"><em><span style="font-family:宋体">cn</span></em><span style="font-family:宋体"> + (-<em>cn</em>/10 + 7<em>c</em> +<em>an</em>) ,</span></span></p></td></tr></tbody></table><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体"><span style="font-size:13px">which is at most<em>cn</em> if</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1304568935P0Zp.jpg" height="15" width="149"></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体; font-size:12pt"><span style="font-size:13px">Inequality (9.2)</span><span style="font-size:13px"> is equivalent to the inequality<em>c</em> ≥ 10<em>a</em>(<em>n</em>/(<em>n</em> - 70)) when <em>n</em> &gt; 70. Because we assume that<em>n</em> ≥ 140, we have <em>n</em>/(<em>n</em> - 70) ≤ 2, and so choosing <em>c</em> ≥ 20<em>a</em> will satisfy</span><span style="font-size:13px">inequality (9.2)</span><span style="font-size:13px">.
 (Note that there is nothing special about the constant 140; we could 
replace it by any integer strictly greater than 70 and then choose<em>c</em> accordingly.) The worst-case running time of SELECT is therefore linear（<strong>因此，此SELECT的最坏情况的运行时间是线性的</strong>）.</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left">&nbsp;</p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体; font-size:12pt"><span style="font-size:13px">&nbsp;&nbsp;&nbsp; As in a comparison sort (see</span><span style="font-size:13px">Section 8.1</span><span style="font-size:13px">),
 SELECT and RANDOMIZED-SELECT determine information about the relative 
order of elements only by comparing elements. Recall from</span><span style="font-size:13px">Chapter 8</span><span style="font-size:13px"> that sorting requires</span></span><span style="font-size:13px"><span lang="EN-US"><span style="font-family:Times New Roman">Ω</span></span><span style="font-family:宋体">(<em>n</em> lg<em>n</em>)
 time in the comparison model, even on average (see Problem 8-1). The 
linear-time sorting algorithms in Chapter 8 make assumptions about the 
input. In contrast, the linear-time selection algorithms in this chapter
 do not require any assumptions about the input. They are not subject to
 the </span><span lang="EN-US"><span style="font-family:Times New Roman">Ω</span></span><span style="font-family:宋体">(<em>n</em> lg<em>n</em>) lower bound because they manage to solve the selection problem without sorting.</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-size:13px"><span style="font-family:宋体">（与
比较排序（算法导论8.1节）中的一样，SELECT和RANDOMIZED-SELECT仅通过元素间的比较来确定它们之间的相对次序。在算法导论第8
章中，我们知道在比较模型中，即使在平均情况下，排序仍然要O（n*logn）的时间。第8章得线性时间排序算法在输入上做了假设。相反地，<strong>本节提到的此类似partition过程的SELECT算法不需要关于输入的任何假设，它们不受下界O（n*logn）的约束，因为它们没有使用排序就解决了选择问题</strong>（看到了没，道出了此算法的本质阿））</span></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left" align="left"><span style="font-family:宋体; font-size:12pt"><span style="font-size:13px">&nbsp;&nbsp;&nbsp;
 Thus, the running time is linear because these algorithms do not sort; 
the linear-time behavior is not a result of assumptions about the input,
 as was the case for the sorting algorithms in</span><span style="font-size:13px">Chapter 8</span><span style="font-size:13px">. Sorting requires</span></span><span style="font-size:13px"><span lang="EN-US"><span style="font-family:Times New Roman">Ω</span></span><span style="font-family:宋体">(<em>n</em> lg<em>n</em>)
 time in the comparison model, even on average (see Problem 8-1), and 
thus the method of sorting and indexing presented in the introduction to
 this chapter is asymptotically 
inefficient.（所以，本节中的选择算法之所以具有线性运行时间，是因为这些算法没有进行排序；线性时间的结论并不需要在输入上所任何假设，即
可得到。.....）</span></span>&nbsp;&nbsp;</p></blockquote><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; padding-left:30px" align="left">&nbsp;</p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; padding-left:30px" align="left">ok，综述全文，根据选取不同的元素作为主元（或枢纽）的情况，可简单总结如下：<br><strong>1、RANDOMIZED-SELECT</strong>，以序列中随机选取一个元素作为主元，可达到线性期望时间O（N）的复杂度。<br>&nbsp;&nbsp;&nbsp; 这个在本文第一节有关编程之美第2.5节关于寻找最大的k个元素（<span style="color:#333333"><strong>但其n*logk的复杂度是严重错误的，待勘误,应以算法导论上的为准，随机选取主元，可达线性期望时间的复杂度</strong></span>），及本文第二节中涉及到的算法导论上第九章第9.2节中（以线性期望时间做选择），都是以随机选取数组中任一元素作为枢纽元的。</p><p class="MsoNormal" style="margin:0cm 0cm 0pt; text-align:left; padding-left:30px" align="left"><strong>2、SELECT，快速选择算法</strong>，以序列中“五分化中项的中项”，或“中位数的中位数”作为主元（枢纽元），则不容置疑的可保证在最坏情况下亦为O（N）的复杂度。<br>&nbsp;&nbsp;&nbsp;
 这个在本文第四节末，及本文第七节，本文文末中都有所阐述，具体涉及到了算法导论一书中第九章第9.3节的最快情况线性时间的选择，及Mark 
Allen Weiss所著的数据结构与算法分析--c语言描述一书的第10章第10.2.3节（选择问题）中，都有所阐述。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:16px">&nbsp; 本文结论</span>：至此，可以毫无保留的确定此问题之结论：<span style="color:#800000">运用类似快速排序的partition的快速选择SELECT算法寻找最小的k个元素能做到O（N）的复杂度。<span style="color:#000000">RANDOMIZED-SELECT<span style="color:#000000">可能会有O（N^2）的最坏的时间复杂度，但上面的SELECT算法，采用如上所述的“中位数的中位数”的取元方法，则<strong>可保证此快速选择算法在最坏情况下是线性时间O（N）的复杂度</strong></span></span></span>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:16px">&nbsp;最终验证：</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 
1、我想，我想，是的，仅仅是我猜想，你可能会有这样的疑问：经过上文大量严谨的论证之后，利用SELECT算法，以序列中“五分化中项的中项”，或“中
位数的中位数”作为主元（枢纽元），的的确确在最坏情况下O（N）的时间复杂度内找到第k小的元素，但是，但是，咱们的要面对的问题是什么?咱们是要找最
小的k个数阿！不是找第k小的元素，而是找最小的k个数（即不是要你找1个数，而是要你找k个数）?哈哈，问题提的非常之好阿。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 
2、事实上，在最坏情况下，能在O（N）的时间复杂度内找到第k小的元素，那么，亦能保证最坏情况下在O（N）的时间复杂度内找到前最小的k个数，咱们得
找到一个理论依据，即一个证明（我想，等你看到找到前k个数的时间复杂度与找第k小的元素，最坏情况下，同样是O（N）的时间复杂度后，你便会100%的
相信本文的结论了，然后可以通告全世界，你找到了这个世界上最靠谱的中文算法blog，ok，这是后话）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法导论第9章第9.3节练习里，有2个题目，与我们将要做的证明是一个道理，请看：</p><blockquote><p><strong>Exercises 9.3-4: ⋆</strong> <br>Suppose
 that an algorithm uses only comparisons to find the ith smallest 
element in a set of n elements. Show that it can also find the i - 1 
smaller elements and the n - i larger elements without performing any 
additional 
comparisons.（假设对一个含有n个元素的集合，某算法只需比较来确定第i小的元素。证明：无需另外的比较操作，它也能找到比i 
小的i-1个元素和比i大的n-i个元素）。</p><p><strong>Exercises 9.3-7</strong> <br>Describe
 an O(n)-time algorithm that, given a set S of n distinct numbers and a 
positive integer k ≤ n, determines the k numbers in S that are closest 
to the median of S.（<strong><span style="color:#333333">给出一个O（N）时间的算法，在给定一个有n个不同数字的集合S以及一个正整数K&lt;=n后，它能确定出S中最接近其中位数的k个数</span></strong>。）</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 怎么样，能证明么?既然通过本文，咱们已经证明了上述的SELECT算法在最坏情况下O（N）的时间内找到第k小的元素，那么距离咱们确切的问题：寻找最小的k个数的证明，只差一步之遥了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>给点提示</strong>：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>1、</strong>找
到了第K小的数Xk 
为O(n)，再遍历一次数组，找出所有比k小的元素O（N）（比较Xk与数组中各数的大小，凡是比Xk小的元素，都是我们要找的元素），最终时间复杂度即
为： O（N）（找到第k小的元素） + 
遍历整个数组O（N）=O（N）。这个结论非常之简单，也无需证明（但是，正如上面的算法导论练习题9.3-7所述，能否在找到第k小的元素后，能否不需
要再比较元素列?）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>2、</strong>我们的问题
是，找到 第k小的元素后Xk，是否Xk之前的元素就是我们 要找的最小 的k个数，即，Xk前面的数，是否都&lt;=Xk?因为 那样的话，复杂度则
 变为：O（N）+O（K）（遍历找到的第k小元素 前面的k个元素）=O（N+K）=O（N），最坏情况下，亦是线性时间。</p><p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#800000">终极结论</span>：证明只有一句话：因为本文我们所有的讨论都是基于快速排序的<strong>partition</strong>方法，而这个方法，每次划分之后，都保证了 枢纽元Xk的前边元素统统小于Xk，后边元素统统大于Xk（<span style="color:#808080">当然，如果你是属于那种打破沙锅问到底的人，你可能还想要我证明partition过程中枢纽元素为何能把整个序列分成左小右大两个部分。但这个不属于本文讨论范畴。读者可参考算法导论第7章第7.1节关于partition过程中循环不变式的证明</span>）。所以，正如本文第一节思路5所述在0（n）的时间内找到第k小的元素，然后遍历输出前面的k个小的元素。如此，再次验证了咱们之前得到的结论：<span style="color:#800000">运用类似快速排序的partition的快速选择SELECT算法寻找最小的k个元素，在最坏情况下亦能做到O（N）的复杂度。</span></p><blockquote><p>&nbsp;&nbsp;&nbsp; 5、RANDOMIZED-SELECT，每次都是<strong>随机选取</strong>数列中的一个元素作为主元，在0（n）的时间内找到第k小的元素，然后遍历输出前面的k个小的元素。 如果能的话，那么总的时间复杂度为线性期望时间：O（n+k）=<strong>O（n）（当k比较小时）</strong>。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp; 所以列，所以，恭喜你，你找到了这个世界上最靠谱的中文算法blog。</p><blockquote><p>&nbsp;&nbsp;<span style="font-size:16px">&nbsp;&nbsp; updated：</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
我假设，你并不认为并赞同上述那句话：你找到了这个世界上最靠谱的中文算法blog。ok，我再给你一个证据：我再次在编程珠玑II上找到了SELECT
算法能在平均时间O（N）内找出第k小元素的第三个证据。同时，依据书上所说，由于SELECT算法采取partition过程划分整个数组元素，所以在
找到第k小的元素Xk之后，Xk+Xk前面的k个元素即为所要查找的k个元素（下图为编程珠玑II第15章第15.2节的截图，同时各位还可看到，<strong><span style="color:#808080">快速排序是递归的对俩个子序列进行操作，而选择算法只对含有K的那一部分重复操作</span></strong>）。</p><p style="padding-left:30px"><img alt="" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/8394323_1304746614zBZ8.jpg" height="330" width="440"></p><p>&nbsp;&nbsp;&nbsp; 再多余的话，我不想说了。我知道我的确是一个庸人自扰的P民，即没有问题的事情却硬要弄出一堆问题出来，然后再矢志不渝的论证自己的观点不容置疑之正确性。ok，毕。</p></blockquote><p>备注：</p><ul><li>快速选择SELECT算法，虽然复杂度平均是o(n)，但这个系数比较大，与用一个最大堆0(n*logk)不见得就有优势）&nbsp;</li><li>当
K很小时，O（N*logK）与O（N）等价，当K很大时，当然也就不能忽略掉了。也就是说，在我们这个具体寻找k个最小的数的问题中，当我们无法确定K
 的具体值时（是小是大），咱们便不能简单的从表面上忽略。也就是说：O（N*logK）就是O（N*logK），非O（N）。</li></ul><ol><li>如果n=1024,k=n-1,最差情况下需比较2n次，而nlog(k-1)=10n，所以不相同。实际上，这个算法时间复杂度与k没有直接关系。且只在第一次划分的时候用到了K,后面几次划分，是根据实际情况确定的，与K无关了。</li><li>但
k=n/2时也不是nlogk,因为只在第一次划分的时候用到了K,后面几次划分,是根据实际情况确定的,与K无关了。比如a[1001].k=500,
第一次把把a划分成两部分,b和c 
,不妨设b元素个数为400个,c中元素为600个,则下一步应该舍掉a,然后在c中寻找top100,此时k已经变成了100，因此与k无关。</li></ol><ul><li>所以，咱们在表述<strong>快速选择算法的平均时间复杂度时，还是要写成O（N）的，断不可写成O（N*logK）的</strong>。</li></ul><p>参考文献：<br>1、Mark Allen Weiss的数据结构与算法分析--c语言描述，第7章第7.7.6节，线性期望时间的选择算法，第10章第10.2.3节，选择问题<br>2、算法导论，第九章第9.2节，以线性期望时间做选择，第九章第9.3节，最快情况线性时间的选择<br>3、编程之美第一版，第141页，第2.5节 寻找最大的k个数（找最大或最小，一个道理）<br>4、维基百科，<a target="_blank" href="http://en.wikipedia.org/wiki/Selection_algorithm"><span style="color:#002d93">http://en.wikipedia.org/wiki/Selection_algorithm</span></a>。<br>5、M. Blum, R.W. Floyd, V. Pratt, R. Rivest and R. Tarjan, "Time bounds for selection,"<br>J. Comput. System Sci. 7 (1973) 448-461. <br>6、<a target="_blank" href="http://blog.csdn.net/v_JULY_v/archive/2011/03/07/6228235.aspx"><strong>当今世界最受人们重视的十大经典算法</strong></a>里提到的，BFPRT 算法。<br>7、编程珠玑II 第15章第15.2节程序。顺便大赞此书。July、updated，2011.05.07。</p><p>&nbsp;</p><p><strong>&nbsp;&nbsp;&nbsp; 预告：</strong> 程序员面试题狂想曲、第四章（<span style="color:#3366ff">更多有关海量数据处理，及Top K 算法问题（<span style="color:#333333"><strong>此问题已作为第三章续</strong></span>），第四章，择日发布。</span>），五月份发布（近期内事情较多，且昨夜因修正此文足足熬到了凌晨4点（但室内并无海棠花），写一篇文章太耗精力和时间，见谅。有关本人动态，可关注本人微博：<a target="_blank" href="http://weibo.com/julyweibo"><span style="color:#002d93"><strong>http://weibo.com/julyweibo</strong></span></a>。谢谢。July、updated，2011.05.05）。</p><p>ok，有任何问题，欢迎随时指出。谢谢。完。</p><hr><p>&nbsp;</p><p><span style="color:#800000"><strong>。<strong>版权声明：严禁用于商业用途，严禁出版。转载，请注明出处。违者，追究法律责任。</strong></strong></span></p>
</div>



<!-- Baidu Button BEGIN -->
<div id="bdshare" class="bdshare_t bds_tools get-codes-bdshare" style="float: right;">
<a href="#" title="分享到QQ空间" class="bds_qzone"></a>
<a href="#" title="分享到新浪微博" class="bds_tsina"></a>
<a href="#" title="分享到腾讯微博" class="bds_tqq"></a>
<a href="#" title="分享到人人网" class="bds_renren"></a>
<a href="#" title="分享到网易微博" class="bds_t163"></a>
<span class="bds_more">更多</span>
<a title="累计分享3次" href="#" class="shareCount">3</a>
</div>
<!-- Baidu Button END -->


<!--192.168.100.34-->
<ul class="article_next_prev">
            <li class="prev_article"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_shangyipian']);location.href='/v_july_v/article/details/6347454';">上一篇</span><a href="http://blog.csdn.net/v_july_v/article/details/6347454" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_shangyipian'])">程序员编程艺术：第二章、字符串是否包含问题</a></li>
            <li class="next_article"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_xiayipian']);location.href='/v_july_v/article/details/6403777';">下一篇</span><a href="http://blog.csdn.net/v_july_v/article/details/6403777" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_xiayipian'])">程序员编程艺术：第三章续、Top K算法问题的实现</a></li>
</ul>

<!-- Baidu Button BEGIN -->
<script src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/bds_s_v2.js" type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=1536434"></script>

<script type="text/javascript">
    document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)
</script>
<!-- Baidu Button END -->

</div>
      <dl class="blog-associat-tag">
        <dt>主题推荐</dt>
        <dd>
                <a href="http://www.csdn.net/tag/%E7%A8%8B%E5%BA%8F%E5%91%98" target="_blank" class="blog-tage-red">程序员</a> 
                <a href="http://www.csdn.net/tag/%E7%BC%96%E7%A8%8B" target="_blank" class="blog-tage-red">编程</a> 
                <a href="http://www.csdn.net/tag/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E5%AD%A6%E9%99%A2" target="_blank" class="blog-tage-red">麻省理工学院</a> 
                <a href="http://www.csdn.net/tag/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE" target="_blank" class="blog-tage-red">海量数据</a> 
                <a href="http://www.csdn.net/tag/%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91" target="_blank" class="blog-tage-red">维基百科</a> 
        </dd>
    </dl> 
    <dl class="blog-ass-articl tracking-ad" data-mod="popu_17">
        <dt><span>博文推荐</span></dt>
            <dd>
                <a href="http://blog.csdn.net/gaga392464782/article/details/25625021" title="错误修改记录集" target="_blank">错误修改记录集</a></dd>
            <dd>
                <a href="http://blog.csdn.net/lixianlin/article/details/25604779" title="linux c setitimer用法说明" target="_blank">linux c setitimer用法说明</a></dd>
            <dd>
                <a href="http://blog.csdn.net/asnowstar/article/details/25609353" title="传统IT列强和互联网新贵们如何应对大数据浪潮" target="_blank">传统IT列强和互联网新贵们如何应对大数据...</a></dd>
            <dd>
                <a href="http://blog.csdn.net/u014231159/article/details/25605411" title="Bone Collector------HDOJ杭电2602（纯01背包问题！！！！！！详解！）" target="_blank">Bone Collector------...</a></dd>
            <dd>
                <a href="http://blog.csdn.net/sheguolian/article/details/25606609" title="老程序员的经验和价值在哪里？" target="_blank">老程序员的经验和价值在哪里？</a></dd>
            <dd>
                <a href="http://blog.csdn.net/merryy/article/details/25560023" title="打印输入中单词长度的直方图程序" target="_blank">打印输入中单词长度的直方图程序</a></dd>
            <dd>
                <a href="http://blog.csdn.net/luaohan/article/details/25554711" title="用python爬虫抓取搜索引擎的提示关键字" target="_blank">用python爬虫抓取搜索引擎的提示关键字</a></dd>
            <dd>
                <a href="http://blog.csdn.net/ajaxhu/article/details/25554329" title="JAVA程序员怎么才能快速查找到学习资料？" target="_blank">JAVA程序员怎么才能快速查找到学习资料？</a></dd>
    </dl>

    <div id="ad_cen">
        <script type="text/javascript">            BAIDU_CLB_SLOT_ID = "117306";</script>
        <script type="text/javascript" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/o.js"></script><div id="BAIDU_DUP_wrapper_117306_0"></div><script charset="utf-8" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ecom"></script><script charset="utf-8" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/fixed7o.js"></script><script type="text/javascript"><!--
google_ad_client = "ca-pub-1076724771190722";
/* blog正文下方728x90 */
google_ad_slot = "4497271841";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/show_ads.js">
</script><ins style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent"><ins id="aswift_0_anchor" style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;" frameborder="0" height="90" width="728"></iframe></ins></ins>
    </div>
    <script type="text/javascript">
        //new Ad(4, 'ad_cen');
    </script>
<div id="comment_title" class="panel_head">
    查看评论<a name="comments"></a></div>
<div id="comment_list"><dl class="comment_item comment_topic" id="comment_item_3559005"><dt class="comment_head" floor="110">110楼 <span class="user"><a class="username" href="http://blog.csdn.net/longzuyuan" target="_blank">Memo龙</a> <span class="ptime">2014-03-07 11:17发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3559005" username="longzuyuan"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/longzuyuan" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_longzuyuan.jpg" height="40" width="40"></a></dd><dd class="comment_body">LZ的HeapAdjust稍难理解，或许这么写更好理解，但是LZ的可能高效一些。<br><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_9" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" name="ZeroClipboardMovie_9" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=9&amp;width=0&amp;height=0" wmode="transparent" align="middle" height="0" width="0"></div></div></div><ol class="dp-cpp" start="1"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;HeapAdjust(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;len)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;l&nbsp;=&nbsp;(i&lt;&lt;1)&nbsp;+&nbsp;1;&nbsp;</span><span class="comment">//left&nbsp;child:&nbsp;2*i+1</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;smallest&nbsp;=&nbsp;i;&nbsp;</span><span class="comment">//the&nbsp;smallest&nbsp;index</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(l&nbsp;&lt;&nbsp;len)&nbsp;</span><span class="comment">//loop&nbsp;if&nbsp;left&nbsp;child&nbsp;exist</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(a[l]&nbsp;&lt;&nbsp;a[smallest])&nbsp;smallest&nbsp;=&nbsp;l;&nbsp;</span><span class="comment">//left&nbsp;child&nbsp;is&nbsp;smaller</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>((l+1)&lt;len&nbsp;&amp;&amp;&nbsp;a[l+1]&nbsp;&lt;&nbsp;a[smallest])&nbsp;smallest&nbsp;=&nbsp;l&nbsp;+&nbsp;1;&nbsp;</span><span class="comment">//right&nbsp;child&nbsp;exist&nbsp;and&nbsp;smaller,&nbsp;right&nbsp;=&nbsp;left+1</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(i&nbsp;!=&nbsp;smallest)&nbsp;swap(&amp;a[i],&nbsp;&amp;a[smallest]);&nbsp;</span><span class="comment">//smallest&nbsp;is&nbsp;in&nbsp;children</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;</span><span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l&nbsp;=&nbsp;(smallest&lt;&lt;1)&nbsp;+&nbsp;1;&nbsp;<span class="comment">//init&nbsp;next&nbsp;loop</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;smallest;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre style="display: none;" name="code2" class="cpp">void HeapAdjust(int a[], int i, int len)
{
    int l = (i&lt;&lt;1) + 1; //left child: 2*i+1
    int smallest = i; //the smallest index

    while(l &lt; len) //loop if left child exist
    {
        if(a[l] &lt; a[smallest]) smallest = l; //left child is smaller
        if((l+1)&lt;len &amp;&amp; a[l+1] &lt; a[smallest]) smallest = l + 1; //right child exist and smaller, right = left+1

        if(i != smallest) swap(&amp;a[i], &amp;a[smallest]); //smallest is in children
        else break;

        l = (smallest&lt;&lt;1) + 1; //init next loop
        i = smallest;
    }
}
</pre></dd></dl><dl class="comment_item comment_topic" id="comment_item_3558909"><dt class="comment_head" floor="109">109楼 <span class="user"><a class="username" href="http://blog.csdn.net/longzuyuan" target="_blank">Memo龙</a> <span class="ptime">2014-03-07 11:00发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3558909" username="longzuyuan"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/longzuyuan" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_longzuyuan.jpg" height="40" width="40"></a></dd><dd class="comment_body">//q_select places the kth smallest element in a[k]  <br>void q_select( input_type a[], int k, int left, int right )<br>这个方法我试了好多遍，a[k]只会取出第k+1小的数，因为k是比较 i 得来的，一般情况下，k是从1开始，i 是从0开始，除非数组下标改成从1开始！<br>或者传入时改成k-1，比如要获取第6小则传入k值5，但最后位置还是在a[5]，这样的话这句话就要改为：<br>//q_select places the (k+1)th smallest element in a[k]  <br>反过来写(kth:a[k-1])就不对了，因为这个方法确定a[k]，a[k-1]和a[k+1]都无意义（注意这里k一直是指参数k，不是题目的第k）<br>上面是我的个人理解，如有问题还望指出。</dd><dl class="comment_item comment_reply" id="comment_item_3558953"><dt class="comment_head" floor="109">Re: <span class="user"><a class="username" href="http://blog.csdn.net/longzuyuan" target="_blank">Memo龙</a> <span class="ptime">2014-03-07 11:05发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3558953" username="longzuyuan"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/longzuyuan" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_longzuyuan.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复longzuyuan：调用方法：<br><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_10" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" name="ZeroClipboardMovie_10" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=10&amp;width=0&amp;height=0" wmode="transparent" align="middle" height="0" width="0"></div></div></div><ol class="dp-cpp" start="1"><li class="alt"><span><span>q_select(array,&nbsp;K-1,&nbsp;0,&nbsp;MAXLEN-1);&nbsp;</span><span class="comment">//K-1</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>printf(<span class="string">"The&nbsp;%d&nbsp;smallest&nbsp;number&nbsp;is:&nbsp;"</span><span>,&nbsp;array[K-1]);&nbsp;</span><span class="comment">//also&nbsp;should&nbsp;be&nbsp;K-1</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre style="display: none;" name="code2" class="cpp">    q_select(array, K-1, 0, MAXLEN-1); //K-1
    printf("The %d smallest number is: ", array[K-1]); //also should be K-1
</pre></dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_3379945"><dt class="comment_head" floor="108">108楼 <span class="user"><a class="username" href="http://blog.csdn.net/xushan0622" target="_blank">史诗般的man</a> <span class="ptime">2014-01-07 15:12发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3379945" username="xushan0622"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/xushan0622" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_xushan0622.gif" height="40" width="40"></a></dd><dd class="comment_body">mark 下</dd></dl><dl class="comment_item comment_topic" id="comment_item_3268107"><dt class="comment_head" floor="107">107楼 <span class="user"><a class="username" href="http://blog.csdn.net/iezhangbin" target="_blank">江城</a> <span class="ptime">2013-12-09 21:15发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3268107" username="iezhangbin"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/iezhangbin" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_iezhangbin.jpg" height="40" width="40"></a></dd><dd class="comment_body">对第一节中的思路8不是很理解，为什么在输出最小元素之后，取代最小元素的那个相对较大的元素下降K层？就拿图1来说（不能截图，很不爽啊），若取前K=3个最小数据，输出13之后，97取代13登顶，之后97是下降2层，并不是K层。</dd></dl><dl class="comment_item comment_topic" id="comment_item_3193839"><dt class="comment_head" floor="106">106楼 <span class="user"><a class="username" href="http://blog.csdn.net/qw345" target="_blank">qw345</a> <span class="ptime">2013-11-25 13:23发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3193839" username="qw345"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/qw345" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_qw345.gif" height="40" width="40"></a></dd><dd class="comment_body">第一段代码HeapAdjust 有点问题吧，child应该为 2i 而不是2i+1， 不然child[2i+1] 和 child[2i+2]比较是啥意思。退出条件也应该是2i &lt;length, 假如没有右孩子怎么办？，不知我理解的对不对，望回复</dd><dl class="comment_item comment_reply" id="comment_item_3193841"><dt class="comment_head" floor="106">Re: <span class="user"><a class="username" href="http://blog.csdn.net/qw345" target="_blank">qw345</a> <span class="ptime">2013-11-25 13:25发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3193841" username="qw345"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/qw345" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_qw345.gif" height="40" width="40"></a></dd><dd class="comment_body">回复qw345：包括后面的GetMin也是一样的</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_3010429"><dt class="comment_head" floor="105">105楼 <span class="user"><a class="username" href="http://blog.csdn.net/huijian3139" target="_blank">口口竹日门</a> <span class="ptime">2013-10-23 16:55发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3010429" username="huijian3139"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/huijian3139" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_huijian3139.jpg" height="40" width="40"></a></dd><dd class="comment_body">lz，不同意你说的最坏情况是o(n)，即便使用了好的选择枢纽元素策略，最坏情况依然是o(n^2)，好的策略只是从概率上降低坏情况的发生。<br>你引用的”五分化中项的中项“证明只是证明平均情况是o(n)，没有说明是最坏情况。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2977219"><dt class="comment_head" floor="104">104楼 <span class="user"><a class="username" href="http://blog.csdn.net/geicuili" target="_blank">geicuili</a> <span class="ptime">2013-10-12 22:16发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2977219" username="geicuili"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/geicuili" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_geicuili.gif" height="40" width="40"></a></dd><dd class="comment_body">void HeapAdjust(int array[], int i, int Length)  <br>{  <br>    int child,temp;  <br>    for(temp=array[i];2*i+1&lt;Length;i=child)  <br>    {  <br>        child = 2*i+1;  <br>        if(child&lt;Length-1 &amp;&amp; array[child+1]&lt;array[child])  <br>            child++;  <br>        if (temp&gt;array[child])  <br>            array[i]=array[child];  <br>        else  <br>            break;  <br>        array[child]=temp;  <br>    }  <br>}  <br>个人觉得没必要每次下沉都把temp的值真的放在空出的位置，只需找到最后的位置在填进去就可以了。所以建议： array[child]=temp;改为 array[i]=temp;拿到for循环外面。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2738223"><dt class="comment_head" floor="103">103楼 <span class="user"><a class="username" href="http://blog.csdn.net/sustliangbo" target="_blank">pirates</a> <span class="ptime">2013-07-18 16:36发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2738223" username="sustliangbo"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/sustliangbo" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_sustliangbo.jpg" height="40" width="40"></a></dd><dd class="comment_body">堆排序的空间复杂度是O（n）？？？？</dd><dl class="comment_item comment_reply" id="comment_item_2738251"><dt class="comment_head" floor="103">Re: <span class="user"><a class="username" href="http://blog.csdn.net/sustliangbo" target="_blank">pirates</a> <span class="ptime">2013-07-18 16:44发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2738251" username="sustliangbo"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/sustliangbo" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_sustliangbo.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复sustliangbo：好吧，我理解错了。。。</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_2609293"><dt class="comment_head" floor="102">102楼 <span class="user"><a class="username" href="http://blog.csdn.net/sxb15929892495" target="_blank">郎怿</a> <span class="ptime">2013-04-27 00:02发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2609293" username="sxb15929892495"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/sxb15929892495" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_sxb15929892495.jpg" height="40" width="40"></a></dd><dd class="comment_body">佩服，</dd></dl><dl class="comment_item comment_topic" id="comment_item_2604241"><dt class="comment_head" floor="101">101楼 <span class="user"><a class="username" href="http://blog.csdn.net/iwangq" target="_blank">iwangq</a> <span class="ptime">2013-04-23 17:28发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2604241" username="iwangq"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/iwangq" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_iwangq.jpg" height="40" width="40"></a></dd><dd class="comment_body">关
于上述第7点思路的继续阐述：至于思路7的O（n+k*logn）是否小于上述思路3的O（n*logk），即O（n+k*logn）?&lt; 
O（n*logk）。粗略数学证明可参看如下第一幅图，我们可以这么解决：当k是常数，n趋向于无穷大时，求（n*logk）/（n+k*logn）的极
限T，如果T&gt;1，那么可得O（n*logk）&gt;O（n+k*logn），也就是O（n+k*logn）&lt; 
O（n*logk）。虽然这有违我们惯常的思维，然事实最终证明的确如此，这个极值T=logk&gt;1，即采取建立n个元素的最小堆后取其前k个数的
方法的复杂度小于采取常规的建立k个元素最大堆后通过比较寻找最小的k个数的方法的复杂度。但，最重要的是，如果建立n个元素的最小堆的话，那么其空间复
杂度势必为O（N），而建立k个元素的最大堆的空间复杂度为O（k）。所以，综合考虑，我们一般还是选择用建立k个元素的最大堆的方法解决此类寻找最小的
k个数的问题。<br><br>    
也可以如gbb21所述粗略证明：要证原式k+n*logk-n-k*logn&gt;0，等价于证（logk-1）n-k*logn+k&gt;0。当
when n -&gt; 
+/inf（n趋向于正无穷大）时，logk-1-0-0&gt;0，即只要满足logk-1&gt;0即可。原式得证。即
O（k+n*logk）&gt;O（n+k*logn） =&gt;O（n+k*logn）&lt; O（n*logk），与上面得到的结论一致。<br><br><br>这个推论有个地方想问一下：<br>要证明（n*logk）/（n+k*logn）<br>下面的推断是<br>k+n*logk-n-k*logn&gt;0？ 不是n*logk-n-k*logn&gt;0？<br>谢谢</dd><dl class="comment_item comment_reply" id="comment_item_2604291"><dt class="comment_head" floor="101">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2013-04-23 18:00发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2604291" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回
复iwangq：你好，我们先来看下思路3： 
当然，更好的办法是维护k个元素的最大堆，原理与上述第2个方案一致，即用容量为k的最大堆存储最先遍历到的k个数，并假设它们即是最小的k个数，建堆费
时O（k）后，有k1&lt;k2&lt;...&lt;kmax（kmax设为大顶堆中最大元素）。继续遍历数列，每次遍历一个元素x，与堆顶元素比
较，x&lt;kmax，更新堆（用时logk），否则不更新堆。这样下来，总费时O（k+（n-k）*logk）=O（n*logk）。<br><br>也就是说，思路3的时间复杂度准确来说，是O（k+（n-k）*logk）。<br><br>而
思路7的时间复杂度为：7、 updated： 
huaye502在本文的评论下指出：“可以用最小堆初始化数组，然后取这个优先队列前k个值。复杂度O(n)+k*O(log 
n)”。huaye502的意思是针对整个数组序列建最小堆，建堆所用时间为O（n）（算法导论一书上第6章第6.3节已经论证，在线性时间内，能将一个
无序的数组建成一个最小堆），然后取堆中的前k个数，总的时间复杂度即为：O（n+k*logn）。<br><br>也就是说，思路7的时间复杂度为：O（n+k*logn）。<br><br>现在要比较思路3和思路7，哪一个的时间复杂度大或小，对吧？<br>于是，等价于要比较：k+（n-k）*logk与n+k*logn 的大小，因如你上面疑惑的那段所说：“ 也可以如gbb21所述粗略证明：要证原式k+n*logk-n-k*logn&gt;0，等价于证（logk-1）n-k*logn+k&gt;0。”<br><br>不过，这里更准确的表述应该是：<br>也可以如gbb21所述粗略证明：要证原式k+n*logk-klogk-n-k*logn&gt;0，等价于证（logk-1）n - k*logn + k - klogk &gt; 0。<br><br>我再看下，感谢！</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_2593094"><dt class="comment_head" floor="100">100楼 <span class="user"><a class="username" href="http://blog.csdn.net/qeshine" target="_blank">互联网学习中</a> <span class="ptime">2013-04-14 21:50发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2593094" username="qeshine"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/qeshine" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_qeshine.jpg" height="40" width="40"></a></dd><dd class="comment_body">请问堆排序的那个方法中<br>    int j=Length;  <br>    for(i=k;i&gt;0;--i,--j)   <br>        //k次循环，每次循环的复杂度最多为k次交换，复杂度为o(k^2)  <br>    {  <br>        int min=GetMin(array,j,i);  <br>        printf("%d,", min);  <br>    }  <br>getMIn（array，j，i）为啥加上i这个限制？</dd><dl class="comment_item comment_reply" id="comment_item_2593114"><dt class="comment_head" floor="100">Re: <span class="user"><a class="username" href="http://blog.csdn.net/qeshine" target="_blank">互联网学习中</a> <span class="ptime">2013-04-14 22:07发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2593114" username="qeshine"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/qeshine" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_qeshine.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复qeshine：不用那个i的限制也可以吧？</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_2488114"><dt class="comment_head" floor="99">99楼 <span class="user"><a class="username" href="http://blog.csdn.net/zzran" target="_blank">yingsun</a> <span class="ptime">2013-01-01 09:21发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2488114" username="zzran"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zzran" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_zzran.jpg" height="40" width="40"></a></dd><dd class="comment_body">就
是这个思路8中，有个思路是O（n + 
k^2）,原来的时间复杂度为O（n+klogn）,k^2=klogn=&gt;k=logn,也就是说k&lt;logn的时候可以用k^2,假设
n=4GB的int整数,logn = 30,k&lt;30的时候才可以用k的平方,当k &lt; 30 
的时候，对计算机来说是一个非常小的数量级，所以我觉得对于走k步的改动没有必要，当k&gt;30的时候，堆的深度本身是30，调整的深度大于30就会
有错误，我没有试过，但是这个思路八想法是好的，同时也是多余的。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2468182"><dt class="comment_head" floor="98">98楼 <span class="user"><a class="username" href="http://blog.csdn.net/Raul_77" target="_blank">Raul_77</a> <span class="ptime">2012-12-13 22:23发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2468182" username="Raul_77"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Raul_77" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_raul_77.gif" height="40" width="40"></a></dd><dd class="comment_body">关
注v_JULY_v 很久了。作为同龄人，真的佩服你的专研和无私的精神。关注过很多业内牛人的文章，比如绿盟的小四，袁哥等人。v_JULY_v 
兄是一个希望之星啊，有才气有才情。技术牛很多很多，但“大师”却没几个。希望你保持这样的精神，往“大师”靠拢。希望看到你那一天。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2451910"><dt class="comment_head" floor="97">97楼 <span class="user"><a class="username" href="http://blog.csdn.net/ailunfeisite1" target="_blank">ailunfeisite1</a> <span class="ptime">2012-12-01 00:25发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2451910" username="ailunfeisite1"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/ailunfeisite1" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_ailunfeisite1.gif" height="40" width="40"></a></dd><dd class="comment_body">谢谢总结。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2406942"><dt class="comment_head" floor="96">96楼 <span class="user"><a class="username" href="http://blog.csdn.net/oujiachao" target="_blank">oujiachao</a> <span class="ptime">2012-10-20 16:32发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2406942" username="oujiachao"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/oujiachao" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_oujiachao.gif" height="40" width="40"></a></dd><dd class="comment_body">那么多字是一个个打上去的吗？书上应该有吧！其实说来说去还是数学的算法问题，以前很多都忘记了。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2371273"><dt class="comment_head" floor="95">95楼 <span class="user"><a class="username" href="http://blog.csdn.net/gongping11" target="_blank">gongping11</a> <span class="ptime">2012-09-13 19:27发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2371273" username="gongping11"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/gongping11" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_gongping11.jpg" height="40" width="40"></a></dd><dd class="comment_body">看了您的代码发现存在一些小问题，首先是swap实现过程中，首先应该检测两个指针是否是相同的，如果相同，这种实现方法是存在问题的。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2279327"><dt class="comment_head" floor="94">94楼 <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2012-07-11 00:23发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2279327" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">"lei lei" &lt;leisc162@gmail.com&gt;<br>July：<br>   你好！首先感谢你辛勤的脑力劳动，学习你的博客，让人受益匪浅。<br><br>在看&lt;&lt;程序员编程艺术总结&gt;&gt; pdf版时，发现了一个，有待商榷的地方。<br><br>第三章 .寻找最小的K个数<br><br><br>思路8.<br>下移K次，这个思路很好，但是在你的实现中，出现了问题。<br>在函数 int GetMin(int array[],int length ,int k)这样下移，对最小堆的破坏太大了。<br><br>例如 我想取  10 元素中的9个最小的，就会出现问题。<br><br>你的实现，n个元素，只能取 n/2个最小的<br>（当然，n个元素，取n/2+k 最小的，只需要将另外的  n/2-k 个最大的取出来，剩下的就是最小的）</dd></dl><dl class="comment_item comment_topic" id="comment_item_2262467"><dt class="comment_head" floor="93">93楼 <span class="user"><a class="username" href="http://blog.csdn.net/gaohong520" target="_blank">自溟</a> <span class="ptime">2012-06-22 20:56发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2262467" username="gaohong520"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/gaohong520" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_gaohong520.jpg" height="40" width="40"></a></dd><dd class="comment_body">楼主的题主要是从哪里来的？我在学编程时常常就是找不到合适的题目。。。。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2258906"><dt class="comment_head" floor="92">92楼 <span class="user"><a class="username" href="http://blog.csdn.net/titer1" target="_blank">titer1</a> <span class="ptime">2012-06-18 23:15发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2258906" username="titer1"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/titer1" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_titer1.jpg" height="40" width="40"></a></dd><dd class="comment_body">最近又看了v_july_v 的topK算法解释，写了自己的读书笔试，<br>在这里傍个大腿，<br>有空的同学到这里坐坐看看，指教指教：<br><br>66算法系列-66漫谈topK 问题<br>http://blog.chinaunix.net/uid-10780339-id-3247343.html<br><br>为技术交流哈</dd><dl class="comment_item comment_reply" id="comment_item_2259047"><dt class="comment_head" floor="92">Re: <span class="user"><a class="username" href="http://blog.csdn.net/titer1" target="_blank">titer1</a> <span class="ptime">2012-06-19 08:12发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2259047" username="titer1"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/titer1" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_titer1.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复titer1：这是 66算法系列-66漫谈topK 问题 @csdn博客地址<br>http://blog.csdn.net/titer1/article/details/7674947</dd><dl class="comment_item comment_reply" id="comment_item_2260084"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2012-06-19 23:25发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2260084" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复titer1：不错，-_-</dd></dl></dl></dl><dl class="comment_item comment_topic" id="comment_item_2252018"><dt class="comment_head" floor="91">91楼 <span class="user"><a class="username" href="http://blog.csdn.net/wyhhxx17" target="_blank">wyhhxx17</a> <span class="ptime">2012-06-12 13:20发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2252018" username="wyhhxx17"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/wyhhxx17" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_wyhhxx17.gif" height="40" width="40"></a></dd><dd class="comment_body">请问博主这篇文章全面更新的地址在哪里呢？？？</dd></dl><dl class="comment_item comment_topic" id="comment_item_2203376"><dt class="comment_head" floor="90">90楼 <span class="user"><a class="username" href="http://blog.csdn.net/limengxiong" target="_blank">limengxiong</a> <span class="ptime">2012-05-03 16:30发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2203376" username="limengxiong"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/limengxiong" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_limengxiong.jpg" height="40" width="40"></a></dd><dd class="comment_body">第一节  第4种思路中<br> “如果要查找的k个元素小于Sa的元素个数，则返回Sa中较小的k个元素，否则返回Sa中k个小的元素+Sb中小的k-|Sa|个元素。”中第3个k处应为 |Sa|</dd></dl><dl class="comment_item comment_topic" id="comment_item_2202482"><dt class="comment_head" floor="89">89楼 <span class="user"><a class="username" href="http://blog.csdn.net/xtao" target="_blank">xtao</a> <span class="ptime">2012-05-02 22:13发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2202482" username="xtao"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/xtao" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_xtao.gif" height="40" width="40"></a></dd><dd class="comment_body">各位老大，怎么我试了试这文章中的代码，结果都是不对的呢？</dd><dl class="comment_item comment_reply" id="comment_item_2202496"><dt class="comment_head" floor="89">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2012-05-02 22:21发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2202496" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复xtao：具体哪段代码不对，告诉我？</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_2111970"><dt class="comment_head" floor="88">88楼 <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2012-02-27 20:24发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2111970" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">昨日和晓亮讨论了下本文第二节的论证过程...怎么，感觉以前的文章咋这么长阿...太有耐心了..</dd></dl><dl class="comment_item comment_topic" id="comment_item_2031903"><dt class="comment_head" floor="87">87楼 <span class="user"><a class="username" href="http://blog.csdn.net/zlltalent" target="_blank">zlltalent</a> <span class="ptime">2011-11-27 12:28发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2031903" username="zlltalent"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zlltalent" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_zlltalent.gif" height="40" width="40"></a></dd><dd class="comment_body">厉害！</dd></dl><dl class="comment_item comment_topic" id="comment_item_1998249"><dt class="comment_head" floor="86">86楼 <span class="user"><a class="username" href="http://blog.csdn.net/mingdechuan" target="_blank">mingdechuan</a> <span class="ptime">2011-10-26 18:15发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1998249" username="mingdechuan"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/mingdechuan" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_mingdechuan.jpg" height="40" width="40"></a></dd><dd class="comment_body">收获挺大的，再一次感觉算法和数学的重要。。</dd></dl><dl class="comment_item comment_topic" id="comment_item_1996566"><dt class="comment_head" floor="85">85楼 <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-10-25 12:26发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1996566" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">此篇针对寻找最小的k个数的文章总结得很好：http://blog.csdn.net/huagong_adu/article/details/6901924。感谢huagong_adu。</dd><dl class="comment_item comment_reply" id="comment_item_1996664"><dt class="comment_head" floor="85">Re: <span class="user"><a class="username" href="http://blog.csdn.net/huagong_adu" target="_blank">huagong_adu</a> <span class="ptime">2011-10-25 14:19发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1996664" username="huagong_adu"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/huagong_adu" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_huagong_adu.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复v_JULY_v：站在博主巨人的肩膀上，互相学习，互相进步</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_1984616"><dt class="comment_head" floor="84">84楼 <span class="user"><a class="username" href="http://blog.csdn.net/caock123" target="_blank">caock123</a> <span class="ptime">2011-10-12 18:34发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1984616" username="caock123"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/caock123" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_caock123.gif" height="40" width="40"></a></dd><dd class="comment_body">2012网易校园招聘有这个 题目</dd></dl><dl class="comment_item comment_topic" id="comment_item_1979962"><dt class="comment_head" floor="83">83楼 <span class="user"><a class="username" href="http://blog.csdn.net/qzh720" target="_blank">qzh720</a> <span class="ptime">2011-10-08 17:04发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1979962" username="qzh720"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/qzh720" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_qzh720.gif" height="40" width="40"></a></dd><dd class="comment_body">教我们点学习C++，算法的方法呗，不胜感激啊！</dd></dl><dl class="comment_item comment_topic" id="comment_item_1979957"><dt class="comment_head" floor="82">82楼 <span class="user"><a class="username" href="http://blog.csdn.net/qzh720" target="_blank">qzh720</a> <span class="ptime">2011-10-08 17:02发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1979957" username="qzh720"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/qzh720" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_qzh720.gif" height="40" width="40"></a></dd><dd class="comment_body">楼主，你怎么知道这么多，这么厉害，是不是天天都泡在算法里面啊</dd></dl><dl class="comment_item comment_topic" id="comment_item_1979141"><dt class="comment_head" floor="81">81楼 <span class="user"><a class="username" href="http://blog.csdn.net/sjtucyz" target="_blank">sjtucyz</a> <span class="ptime">2011-10-07 21:16发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1979141" username="sjtucyz"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/sjtucyz" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_sjtucyz.gif" height="40" width="40"></a></dd><dd class="comment_body">想问一下怎么实现BFPRT算法呢，感觉实现起来好复杂啊···</dd></dl><dl class="comment_item comment_topic" id="comment_item_1979109"><dt class="comment_head" floor="80">80楼 <span class="user"><a class="username" href="http://blog.csdn.net/sjtucyz" target="_blank">sjtucyz</a> <span class="ptime">2011-10-07 20:51发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1979109" username="sjtucyz"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/sjtucyz" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_sjtucyz.gif" height="40" width="40"></a></dd><dd class="comment_body">太厉害了，以后要常来取经！</dd></dl><dl class="comment_item comment_topic" id="comment_item_1978441"><dt class="comment_head" floor="79">79楼 <span class="user"><a class="username" href="http://blog.csdn.net/hanzhaoshuai" target="_blank">hanzhaoshuai</a> <span class="ptime">2011-10-06 17:01发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1978441" username="hanzhaoshuai"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/hanzhaoshuai" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_hanzhaoshuai.jpg" height="40" width="40"></a></dd><dd class="comment_body">楼主功力深厚！</dd></dl><dl class="comment_item comment_topic" id="comment_item_1948855"><dt class="comment_head" floor="78">78楼 <span class="user"><a class="username" href="http://blog.csdn.net/hardbrave" target="_blank">星河天璇</a> <span class="ptime">2011-09-06 09:13发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1948855" username="hardbrave"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/hardbrave" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_hardbrave.jpg" height="40" width="40"></a></dd><dd class="comment_body">内容丰富，论证翔实，这是博文值得称道之处。可不得不说，博文的排版真挺混乱的，各种穿插的update和思路，实在是看得头晕眼花，不分重点。。。个人观点，不喜勿喷~~</dd></dl><dl class="comment_item comment_topic" id="comment_item_1943040"><dt class="comment_head" floor="77">77楼 <span class="user"><a class="username" href="http://blog.csdn.net/luckyguy_sy" target="_blank">luckyguy_sy</a> <span class="ptime">2011-08-31 10:35发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1943040" username="luckyguy_sy"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/luckyguy_sy" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_luckyguy_sy.gif" height="40" width="40"></a></dd><dd class="comment_body">mark,后面慢慢看</dd></dl><dl class="comment_item comment_topic" id="comment_item_1873585"><dt class="comment_head" floor="76">76楼 <span class="user"><a class="username" href="http://blog.csdn.net/my8688" target="_blank">my8688</a> <span class="ptime">2011-08-12 15:49发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1873585" username="my8688"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/my8688" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_my8688.jpg" height="40" width="40"></a></dd><dd class="comment_body">真的不错，多多学习。只是：<br>楼主，第一个堆排序的代码好像有问题，不能正确取到前k小啊，会出现重复的。例如从10个元素的数组中取最小的5个数：<br>#include &lt;stdio.h&gt;   <br>#include &lt;stdlib.h&gt;   <br>#define MAXLEN 10<br>#define K 5  <br>……<br>int main()  <br>{  <br>    int array[MAXLEN]={1,3,5,7,9,2,4,6,8,0};  <br>    int i=0;<br>    //for(i=MAXLEN;i&gt;0;--i)  <br>        //array[MAXLEN-i] = i;  <br>      <br>    Kmin(array,MAXLEN,K);  <br>    return 0;  <br>}  <br>执行结果为：0,1,2,3,0<br>其他情况，也有问题。</dd><dl class="comment_item comment_reply" id="comment_item_1873596"><dt class="comment_head" floor="76">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-08-12 15:53发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1873596" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复my8688：恩，非常感谢。日后一定进行测试以期修正。谢谢你。</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_1865673"><dt class="comment_head" floor="75">75楼 <span class="user"><a class="username" href="http://blog.csdn.net/fengcman" target="_blank">fengcman</a> <span class="ptime">2011-08-05 14:55发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1865673" username="fengcman"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/fengcman" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_fengcman.gif" height="40" width="40"></a></dd><dd class="comment_body">楼主写了这么多，给我的一种感觉有点乱。<br>我粗略的看了一下楼主的几种方案，好像下面这种没有提到。<br>从
n个数中取k个数进行排序，当然还是快排吧(klogk)，毕竟从时间复杂度上看还是挺让人喜爱的，然后对后面n-k个元素进行遍历，对于取到的数，先与
最大(最小)进行比较(当然这步可可以不用)，如果满足条件，进行二分查找，将该数插入到k个数组中(这里我们可以使用链表进行快速的插入，去除最大(最
小)值)。如果我没有估计错误的话，总的时间复杂度为K*logK + (n-k)logK</dd><dl class="comment_item comment_reply" id="comment_item_1865741"><dt class="comment_head" floor="75">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-08-05 15:43发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1865741" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复fengcman：我最讨厌的回复，就是含有粗略两字。</dd><dl class="comment_item comment_reply" id="comment_item_1865848"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/fengcman" target="_blank">fengcman</a> <span class="ptime">2011-08-05 16:38发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1865848" username="fengcman"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/fengcman" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_fengcman.gif" height="40" width="40"></a></dd><dd class="comment_body">回复v_JULY_v：我说说的粗略意思是：只看了该贴的几种思路，大致都清楚了，没有细致的去看楼主的解释，可能会有跟楼主想的不一样的地方，故我这么说。<br>我想，我提的那种楼主应该没有说到吧，不过跟楼主的几种方案有相似的地方。</dd></dl><dl class="comment_item comment_reply" id="comment_item_1865826"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/fengcman" target="_blank">fengcman</a> <span class="ptime">2011-08-05 16:29发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1865826" username="fengcman"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/fengcman" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_fengcman.gif" height="40" width="40"></a></dd><dd class="comment_body">回复v_JULY_v：不好意思，玷污你的作品了</dd><dl class="comment_item comment_reply" id="comment_item_1865832"><dt class="comment_head" floor="2">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-08-05 16:32发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1865832" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复fengcman：没有。我习惯严谨细致。</dd></dl></dl></dl></dl><dl class="comment_item comment_topic" id="comment_item_1805953"><dt class="comment_head" floor="74">74楼 <span class="user"><a class="username" href="http://blog.csdn.net/zhenjing" target="_blank">zhenjing</a> <span class="ptime">2011-06-23 22:54发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1805953" username="zhenjing"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zhenjing" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_zhenjing.jpg" height="40" width="40"></a></dd><dd class="comment_body">终极结论：-----每次划分之后，都保证了 枢纽元Xk的前边元素统统小于Xk，后边元素统统大于Xk。<br>==========<br>partition不保证和枢纽元Xk相等的元素的位置！文中有几个地方有这么个小小的笔误。</dd><dl class="comment_item comment_reply" id="comment_item_1807987"><dt class="comment_head" floor="74">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-06-27 00:46发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1807987" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 zhenjing：非常感谢。改日细看修正。</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_1800657"><dt class="comment_head" floor="73">73楼 <span class="user"><a class="username" href="http://blog.csdn.net/parakpurple" target="_blank">parakpurple</a> <span class="ptime">2011-06-17 20:41发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1800657" username="parakpurple"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/parakpurple" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_parakpurple.jpg" height="40" width="40"></a></dd><dd class="comment_body">我的天  作者好敬业啊 真严谨</dd><dl class="comment_item comment_reply" id="comment_item_1800661"><dt class="comment_head" floor="73">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-06-17 20:54发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1800661" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 parakpurple：谢谢，[e10]</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_1798879"><dt class="comment_head" floor="72">72楼 <span class="user"><a class="username" href="http://blog.csdn.net/huaxiangsl" target="_blank">huaxiangsl</a> <span class="ptime">2011-06-16 01:39发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1798879" username="huaxiangsl"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/huaxiangsl" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_huaxiangsl.jpg" height="40" width="40"></a></dd><dd class="comment_body">楼主很有心啊，要是让我写第k小的数，<br>肯定是一个快排，然后直接取数了。。。</dd></dl><dl class="comment_item comment_topic" id="comment_item_1797893"><dt class="comment_head" floor="71">71楼 <span class="user"><a class="username" href="http://blog.csdn.net/sylcc_" target="_blank">sylcc_</a> <span class="ptime">2011-06-15 09:37发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1797893" username="sylcc_"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/sylcc_" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_sylcc_.jpg" height="40" width="40"></a></dd><dd class="comment_body">这就是传说中的介于牛A与牛C之间的人<br>[e01][e03][e03][e03]</dd></dl><dl class="comment_item comment_topic" id="comment_item_1797701"><dt class="comment_head" floor="70">70楼 <span class="user"><a class="username" href="http://blog.csdn.net/yangfengflytosky" target="_blank">yangfengflytosky</a> <span class="ptime">2011-06-14 22:53发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1797701" username="yangfengflytosky"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/yangfengflytosky" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_yangfengflytosky.gif" height="40" width="40"></a></dd><dd class="comment_body">[e01][e01][e01][e01][e01][e01][e01][e01]</dd></dl><dl class="comment_item comment_topic" id="comment_item_1793955"><dt class="comment_head" floor="69">69楼 <span class="user"><a class="username" href="http://blog.csdn.net/chong_boy" target="_blank">chong_boy</a> <span class="ptime">2011-06-10 11:30发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1793955" username="chong_boy"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/chong_boy" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_chong_boy.gif" height="40" width="40"></a></dd><dd class="comment_body">不好意思,没看完全文就评论了,原来楼主已经将问题解决,见谅见谅.</dd><dl class="comment_item comment_reply" id="comment_item_1793999"><dt class="comment_head" floor="69">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-06-10 12:11发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1793999" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 chong_boy：建议你还看看本博客内其它文章，不必死拘泥于这个编程艺术系列。说实话，这个系列，写的有点糟糕。正待日趋完善。</dd></dl><dl class="comment_item comment_reply" id="comment_item_1793996"><dt class="comment_head" floor="69">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-06-10 12:08发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1793996" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 chong_boy：[e03]</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_1793954"><dt class="comment_head" floor="68">68楼 <span class="user"><a class="username" href="http://blog.csdn.net/chong_boy" target="_blank">chong_boy</a> <span class="ptime">2011-06-10 11:28发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1793954" username="chong_boy"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/chong_boy" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_chong_boy.gif" height="40" width="40"></a></dd><dd class="comment_body">考虑排序则不存在θ(n)的算法,显然易见,当k为n时,问题就是θ(n)时间内对n个数排序,这是不可能的.当然特殊数据是存在θ(n)的时间,但若讨论就没意义了.</dd></dl><dl class="comment_item comment_topic" id="comment_item_1793952"><dt class="comment_head" floor="67">67楼 <span class="user"><a class="username" href="http://blog.csdn.net/chong_boy" target="_blank">chong_boy</a> <span class="ptime">2011-06-10 11:27发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1793952" username="chong_boy"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/chong_boy" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_chong_boy.gif" height="40" width="40"></a></dd><dd class="comment_body">建议楼主有时间看看算法导论.寻找最小的k个元素,如果不考虑排序,均摊上是可以达到的.可以将问题转化为寻找第k小的元素(参见算法导论或者网络资料),均摊是θ(n)复杂度.再寻找比第k个元素小的元素即可,也就扫描一遍,耗时θ(n).总的复杂度是θ(n);</dd></dl><dl class="comment_item comment_topic" id="comment_item_1791266"><dt class="comment_head" floor="66">66楼 <span class="user"><a class="username" href="http://blog.csdn.net/meimeng515" target="_blank">meimeng515</a> <span class="ptime">2011-06-07 22:36发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1791266" username="meimeng515"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/meimeng515" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_meimeng515.gif" height="40" width="40"></a></dd><dd class="comment_body">”且昨夜因修正此文足足熬到了凌晨“----我要是有楼主精神，何愁好OFFER呀？？？[e03]</dd></dl><dl class="comment_item comment_topic" id="comment_item_1790340"><dt class="comment_head" floor="65">65楼 <span class="user"><a class="username" href="http://blog.csdn.net/LZQGdut" target="_blank">LZQGdut</a> <span class="ptime">2011-06-07 07:55发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1790340" username="LZQGdut"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/LZQGdut" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_lzqgdut.jpg" height="40" width="40"></a></dd><dd class="comment_body">同样一本书，为什么你就能看出这么多东西来呢……自叹不如啊！anyway，送上一句，辛苦了[e01]</dd><dl class="comment_item comment_reply" id="comment_item_1790358"><dt class="comment_head" floor="65">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-06-07 08:37发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1790358" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 LZQGdut：一起加油。</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_1789635"><dt class="comment_head" floor="64">64楼 <span class="user"><a class="username" href="http://blog.csdn.net/yahier" target="_blank">yahier</a> <span class="ptime">2011-06-05 18:15发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1789635" username="yahier"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/yahier" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_yahier.jpg" height="40" width="40"></a></dd><dd class="comment_body">[e03]学习了一点 不过C代码看的不大懂啊</dd><dl class="comment_item comment_reply" id="comment_item_1789643"><dt class="comment_head" floor="64">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-06-05 18:45发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1789643" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 yahier：也学java的?</dd><dl class="comment_item comment_reply" id="comment_item_1794507"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/yahier" target="_blank">yahier</a> <span class="ptime">2011-06-10 19:21发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1794507" username="yahier"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/yahier" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_yahier.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 v_JULY_v：是啊</dd></dl></dl></dl><dl class="comment_item comment_topic" id="comment_item_1787871"><dt class="comment_head" floor="63">63楼 <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-06-03 09:02发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1787871" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">全文第一次修善完毕。</dd></dl><dl class="comment_item comment_topic" id="comment_item_1787853"><dt class="comment_head" floor="62">62楼 <span class="user"><a class="username" href="http://blog.csdn.net/zhoubiyu" target="_blank">zhoubiyu</a> <span class="ptime">2011-06-03 08:34发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1787853" username="zhoubiyu"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zhoubiyu" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_zhoubiyu.gif" height="40" width="40"></a></dd><dd class="comment_body">[e03][e01][e01][e01][e01][e01][e01][e01][e01][e01]</dd></dl><dl class="comment_item comment_topic" id="comment_item_1690589"><dt class="comment_head" floor="61">61楼 <span class="user"><a class="username" href="http://blog.csdn.net/weiliming123" target="_blank">weiliming123</a> <span class="ptime">2011-06-02 22:47发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1690589" username="weiliming123"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/weiliming123" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_weiliming123.gif" height="40" width="40"></a></dd><dd class="comment_body">没有O（n）的解法，如果有的话，那么k取n，就是对数组排序了，而数组排序是不能在O（n）内完成的。</dd><dl class="comment_item comment_reply" id="comment_item_1690595"><dt class="comment_head" floor="61">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-06-02 22:53发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1690595" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 weiliming123：不需要排序。</dd></dl><dl class="comment_item comment_reply" id="comment_item_1690594"><dt class="comment_head" floor="61">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-06-02 22:53发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1690594" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 weiliming123：有的，文中已经证明了快速选择SELECT算法可以做到O（N）。具体可仔细看原文。</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_1678458"><dt class="comment_head" floor="60">60楼 <span class="user"><a class="username" href="http://blog.csdn.net/h_Mastude" target="_blank">h_Mastude</a> <span class="ptime">2011-05-22 23:12发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1678458" username="h_Mastude"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/h_Mastude" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_h_mastude.gif" height="40" width="40"></a></dd><dd class="comment_body">[e01]楼主果然功力深厚,,不知楼主是大几的呢？为什么感觉完全就不是一个层面上的。文章写的很不错，分析的也太好了。佩服佩服</dd><dl class="comment_item comment_reply" id="comment_item_1679488"><dt class="comment_head" floor="60">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-05-23 23:17发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1679488" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 h_Mastude：谢谢，[e10]</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_1669440"><dt class="comment_head" floor="59">59楼 <span class="user"><a class="username" href="http://blog.csdn.net/eaglex" target="_blank">eaglex</a> <span class="ptime">2011-05-13 08:54发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1669440" username="eaglex"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/eaglex" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_eaglex.jpg" height="40" width="40"></a></dd><dd class="comment_body">当初学算法的时候select的O(n)的 证明是用一个递推的方程<br>类似主定理<br>把n分成了两个和不为n的操作 5分的时候是 n/5 + 7/10n<br>而且我当时研究了下了五分是最小的 三分就不行 n/3 + 2n/3<br><br>前K小确实是一句话就证明了 都是以k划分成两部分的</dd><dl class="comment_item comment_reply" id="comment_item_1669519"><dt class="comment_head" floor="59">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-05-13 09:51发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1669519" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 eaglex：[e03]</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_1669110"><dt class="comment_head" floor="58">58楼 <span class="user"><a class="username" href="http://blog.csdn.net/shnxin" target="_blank">shnxin</a> <span class="ptime">2011-05-12 17:47发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1669110" username="shnxin"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/shnxin" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_shnxin.jpg" height="40" width="40"></a></dd><dd class="comment_body">SELECT算法简直太神了，哪儿有这个算法的实现？</dd><dl class="comment_item comment_reply" id="comment_item_1671630"><dt class="comment_head" floor="58">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-05-15 22:35发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1671630" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 shnxin：SELECT算法，我们已经实现，择日公布。以期共同完善，优化。</dd></dl><dl class="comment_item comment_reply" id="comment_item_1669238"><dt class="comment_head" floor="58">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-05-12 20:54发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1669238" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 shnxin：容我 日后考虑实现。</dd><dl class="comment_item comment_reply" id="comment_item_1669336"><dt class="comment_head" floor="2">Re: <span class="user"><a class="username" href="http://blog.csdn.net/shnxin" target="_blank">shnxin</a> <span class="ptime">2011-05-12 23:00发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1669336" username="shnxin"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/shnxin" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_shnxin.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 v_JULY_v：楼主辛苦 并期待中。。。</dd><dl class="comment_item comment_reply" id="comment_item_1674965"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-05-19 08:59发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1674965" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 shnxin：朋友，在最新更新的文章里，源码已经发布了。巧的是，正好是一个星期，[e04]</dd></dl><dl class="comment_item comment_reply" id="comment_item_1669347"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-05-12 23:11发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1669347" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 shnxin：en，一个星期之后，再来。</dd></dl></dl></dl></dl><dl class="comment_item comment_topic" id="comment_item_1668963"><dt class="comment_head" floor="57">57楼 <span class="user"><a class="username" href="http://blog.csdn.net/lines2005" target="_blank">lines2005</a> <span class="ptime">2011-05-12 16:29发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1668963" username="lines2005"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/lines2005" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_lines2005.jpg" height="40" width="40"></a></dd><dd class="comment_body">[e01]<br>写了这么多！楼主辛苦</dd></dl><dl class="comment_item comment_topic" id="comment_item_1664600"><dt class="comment_head" floor="56">56楼 <span class="user"><a class="username" href="http://blog.csdn.net/tigerjb" target="_blank">冀博</a> <span class="ptime">2011-05-08 14:03发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1664600" username="tigerjb"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/tigerjb" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_tigerjb.jpg" height="40" width="40"></a></dd><dd class="comment_body">呵呵，厉害呀[e10]</dd></dl><dl class="comment_item comment_topic" id="comment_item_1663876"><dt class="comment_head" floor="55">55楼 <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-05-07 11:52发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1663876" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">现，能以人格担保本文结论之100%精准。</dd></dl><dl class="comment_item comment_topic" id="comment_item_1663565"><dt class="comment_head" floor="54">54楼 <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-05-06 22:49发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1663565" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">这个世界上最靠谱的中文blog。</dd></dl><dl class="comment_item comment_topic" id="comment_item_1663105"><dt class="comment_head" floor="53">53楼 <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-05-06 15:17发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1663105" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">欢迎，各位随时指正本文，或本狂想曲系列，或本blog中任何一篇文章，任何一个小问题，及错误，包括标点符号，文字错误。一经确认，立马修正。</dd><dl class="comment_item comment_reply" id="comment_item_1664264"><dt class="comment_head" floor="53">Re: <span class="user"><a class="username" href="http://blog.csdn.net/xuruiyang" target="_blank">xuruiyang</a> <span class="ptime">2011-05-07 22:27发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1664264" username="xuruiyang"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/xuruiyang" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_xuruiyang.jpg" height="40" width="40"></a></dd><dd class="comment_body">回复 v_JULY_v：佩服博主的钻研精神！</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_1662204"><dt class="comment_head" floor="52">52楼 <span class="user"><a class="username" href="http://blog.csdn.net/wzb56" target="_blank">wzb56</a> <span class="ptime">2011-05-05 18:30发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1662204" username="wzb56"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/wzb56" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_wzb56.jpg" height="40" width="40"></a></dd><dd class="comment_body">[e03][e01]</dd></dl><dl class="comment_item comment_topic" id="comment_item_1661888"><dt class="comment_head" floor="51">51楼 <span class="user"><a class="username" href="http://blog.csdn.net/qw1231230" target="_blank">qw1231230</a> <span class="ptime">2011-05-05 15:27发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1661888" username="qw1231230"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/qw1231230" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_qw1231230.gif" height="40" width="40"></a></dd><dd class="comment_body">[e01][e03]</dd></dl><dl class="comment_item comment_topic" id="comment_item_1661886"><dt class="comment_head" floor="50">50楼 <span class="user"><a class="username" href="http://blog.csdn.net/qw1231230" target="_blank">qw1231230</a> <span class="ptime">2011-05-05 15:27发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1661886" username="qw1231230"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/qw1231230" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_qw1231230.gif" height="40" width="40"></a></dd><dd class="comment_body">真狠啊！还让人睡觉不啊！高深啊！</dd></dl><dl class="comment_item comment_topic" id="comment_item_1661801"><dt class="comment_head" floor="49">49楼 <span class="user"><a class="username" href="http://blog.csdn.net/shajia2009" target="_blank">shajia2009</a> <span class="ptime">2011-05-05 14:27发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1661801" username="shajia2009"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/shajia2009" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_shajia2009.gif" height="40" width="40"></a></dd><dd class="comment_body">[e01]利害</dd></dl><dl class="comment_item comment_topic" id="comment_item_1661720"><dt class="comment_head" floor="48">48楼 <span class="user"><a class="username" href="http://blog.csdn.net/piaobiao2008" target="_blank">piaobiao2008</a> <span class="ptime">2011-05-05 13:17发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1661720" username="piaobiao2008"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/piaobiao2008" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_piaobiao2008.jpg" height="40" width="40"></a></dd><dd class="comment_body">[e01],我只能说利害了。都研究到这地步了</dd></dl><dl class="comment_item comment_topic" id="comment_item_1661696"><dt class="comment_head" floor="47">47楼 <span class="user"><a class="username" href="http://blog.csdn.net/v_JULY_v" target="_blank">v_JULY_v</a> <span class="ptime">2011-05-05 12:47发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display: none;" commentid="1661696" username="v_JULY_v"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/v_JULY_v" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_v_july_v.jpg" height="40" width="40"></a></dd><dd class="comment_body">此篇文章耗费了我几天几夜，尤其是昨夜为了论证O（N）的结论，熬到了凌晨4点。现在，此篇文章update后的结论，可以说是非常之精准了。July、2011.05.05。</dd></dl><dl class="comment_item comment_topic" id="comment_item_1661653"><dt class="comment_head" floor="46">46楼 <span class="user"><a class="username" href="http://blog.csdn.net/ZQQ1990" target="_blank">ZQQ1990</a> <span class="ptime">2011-05-05 12:01发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display: none;" commentid="1661653" username="ZQQ1990"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/ZQQ1990" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_zqq1990.gif" height="40" width="40"></a></dd><dd class="comment_body">真的好复杂哦  看不懂了</dd></dl><dl class="comment_item comment_topic" id="comment_item_1661627"><dt class="comment_head" floor="45">45楼 <span class="user"><a class="username" href="http://blog.csdn.net/huner321" target="_blank">huner321</a> <span class="ptime">2011-05-05 11:35发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display: none;" commentid="1661627" username="huner321"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/huner321" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/3_huner321.gif" height="40" width="40"></a></dd><dd class="comment_body">好文</dd></dl><div class="clear"></div></div>
<div id="comment_bar"><div id="load_comments" page="2">查看更多评论</div></div>
<div id="comment_form"><div class="guest_link">您还没有登录,请<a href="javascript:void(0);" onclick="javascript:csdn.showLogin(function (dat) {js_logined(dat.data.userName);});">[登录]</a>或<a href="http://passport.csdn.net/account/register?from=http%3A%2F%2Fblog.csdn.net%2Fv_JULY_v%2Farticle%2Fdetails%2F6370650">[注册]</a></div></div>
<div class="announce">
    * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场<a name="reply"></a><a name="quote"></a></div>
<script type="text/javascript">
    var fileName = '6370650';
    var commentscount = 178;
    var islock = false
</script>
<script type="text/javascript" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/comment.js"></script>
    <div id="ad_bot">
    <iframe src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ad.htm" style="border-width: 0px; overflow: hidden; width: 746px; height: 169px;" scrolling="no" id="ad_frm_0" frameborder="0"></iframe></div>
    <script type="text/javascript">
    new Ad(5, 'ad_bot');
    </script>
<div id="report_dialog">
</div>

<div id="d-top" style="bottom:60px;">
      

       <a id="quick-reply" class="btn btn-top q-reply" title="快速回复" style="display:none;">
            <img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/blog-icon-reply.png" alt="快速回复">
        </a>    

    <a id="d-top-a" class="btn btn-top backtop" style="display: block;" title="返回顶部" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_huidaodingbu'])">         
         <img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/top.png" alt="TOP">
    </a>
</div>
<script type="text/javascript">
    $(function ()
    {
        if($("#comment_content").length>0)
        {
            $("#quick-reply").show();

            $("#quick-reply").click(function(){
                setEditorFocus();
            });
        }       
     
        var d_top = $('#d-top-a');
        document.onscroll = function ()
        {
            var scrTop = (document.body.scrollTop || document.documentElement.scrollTop);
            if (scrTop > 500)
            {
                d_top.show();
            } else
            {
                d_top.hide();
            }
        }
        $('#d-top-a').click(function ()
        {
            scrollTo(0, 0);
            this.blur();
            return false;
        });
    });
  
</script>
<style type="text/css">
    .tag_list
    {
        background: none repeat scroll 0 0 #FFFFFF;
        border: 1px solid #D7CBC1;
        color: #000000;
        font-size: 12px;
        line-height: 20px;
        list-style: none outside none;
        margin: 10px 2% 0 1%;
        padding: 1px;
    }
    .tag_list h5
    {
        background: none repeat scroll 0 0 #E0DBD3;
        color: #47381C;
        font-size: 12px;
        height: 24px;
        line-height: 24px;
        padding: 0 5px;
        margin: 0;
    }
    .tag_list h5 a
    {
        color: #47381C;
    }
    .classify
    {
        margin: 10px 0;
        padding: 4px 12px 8px;
    }
    .classify a
    {
        margin-right: 20px;
        white-space: nowrap;
    }
</style>
<div class="tag_list">
    <h5>
        <a href="http://www.csdn.net/tag/" target="_blank">核心技术类目</a></h5>
    <div class="classify">
<a title="全部主题" href="http://www.csdn.net/tag" target="_blank" onclick="LogClickCount(this,336);">全部主题</a>
<a title="Java" href="http://www.csdn.net/tag/Java" target="_blank" onclick="LogClickCount(this,336);">Java</a>
<a title="VPN" href="http://www.csdn.net/tag/vpn" target="_blank" onclick="LogClickCount(this,336);">VPN</a>
<a title="Android" href="http://www.csdn.net/tag/android" target="_blank" onclick="LogClickCount(this,336);">Android</a>
<a title="iOS" href="http://www.csdn.net/tag/ios" target="_blank" onclick="LogClickCount(this,336);">iOS</a>
<a title="ERP" href="http://www.csdn.net/tag/erp" target="_blank" onclick="LogClickCount(this,336);">ERP</a>
<a title="IE10" href="http://www.csdn.net/tag/ie10" target="_blank" onclick="LogClickCount(this,336);">IE10</a>
<a title="Eclipse" href="http://www.csdn.net/tag/eclipse" target="_blank" onclick="LogClickCount(this,336);">Eclipse</a>
<a title="CRM" href="http://www.csdn.net/tag/crm" target="_blank" onclick="LogClickCount(this,336);">CRM</a>
<a title="JavaScript" href="http://www.csdn.net/tag/javascript" target="_blank" onclick="LogClickCount(this,336);">JavaScript</a>
<a title="Ubuntu" href="http://www.csdn.net/tag/ubuntu" target="_blank" onclick="LogClickCount(this,336);">Ubuntu</a>
<a title="NFC" href="http://www.csdn.net/tag/nfc" target="_blank" onclick="LogClickCount(this,336);">NFC</a>
<a title="WAP" href="http://www.csdn.net/tag/wap" target="_blank" onclick="LogClickCount(this,336);">WAP</a>
<a title="jQuery" href="http://www.csdn.net/tag/jquery" target="_blank" onclick="LogClickCount(this,336);">jQuery</a>
<a title="数据库" href="http://www.csdn.net/tag/%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" onclick="LogClickCount(this,336);">数据库</a>
<a title="BI" href="http://www.csdn.net/tag/bi" target="_blank" onclick="LogClickCount(this,336);">BI</a>
<a title="HTML5" href="http://www.csdn.net/tag/html5" target="_blank" onclick="LogClickCount(this,336);">HTML5</a>
<a title="Spring" href="http://www.csdn.net/tag/spring" target="_blank" onclick="LogClickCount(this,336);">Spring</a>
<a title="Apache" href="http://www.csdn.net/tag/apache" target="_blank" onclick="LogClickCount(this,336);">Apache</a>
<a title="Hadoop" href="http://www.csdn.net/tag/hadoop" target="_blank" onclick="LogClickCount(this,336);">Hadoop</a>
<a title=".NET" href="http://www.csdn.net/tag/.net" target="_blank" onclick="LogClickCount(this,336);">.NET</a>
<a title="API" href="http://www.csdn.net/tag/api" target="_blank" onclick="LogClickCount(this,336);">API</a>
<a title="HTML" href="http://www.csdn.net/tag/html" target="_blank" onclick="LogClickCount(this,336);">HTML</a>
<a title="SDK" href="http://www.csdn.net/tag/sdk" target="_blank" onclick="LogClickCount(this,336);">SDK</a>
<a title="IIS" href="http://www.csdn.net/tag/iis" target="_blank" onclick="LogClickCount(this,336);">IIS</a>
<a title="Fedora" href="http://www.csdn.net/tag/fedora" target="_blank" onclick="LogClickCount(this,336);">Fedora</a>
<a title="XML" href="http://www.csdn.net/tag/xml" target="_blank" onclick="LogClickCount(this,336);">XML</a>
<a title="LBS" href="http://www.csdn.net/tag/lbs" target="_blank" onclick="LogClickCount(this,336);">LBS</a>
<a title="Unity" href="http://www.csdn.net/tag/unity" target="_blank" onclick="LogClickCount(this,336);">Unity</a>
<a title="Splashtop" href="http://www.csdn.net/tag/splashtop" target="_blank" onclick="LogClickCount(this,336);">Splashtop</a>
<a title="UML" href="http://www.csdn.net/tag/uml" target="_blank" onclick="LogClickCount(this,336);">UML</a>
<a title="components" href="http://www.csdn.net/tag/components" target="_blank" onclick="LogClickCount(this,336);">components</a>
<a title="Windows Mobile" href="http://www.csdn.net/tag/windowsmobile" target="_blank" onclick="LogClickCount(this,336);">Windows Mobile</a>
<a title="Rails" href="http://www.csdn.net/tag/rails" target="_blank" onclick="LogClickCount(this,336);">Rails</a>
<a title="QEMU" href="http://www.csdn.net/tag/qemu" target="_blank" onclick="LogClickCount(this,336);">QEMU</a>
<a title="KDE" href="http://www.csdn.net/tag/kde" target="_blank" onclick="LogClickCount(this,336);">KDE</a>
<a title="Cassandra" href="http://www.csdn.net/tag/cassandra" target="_blank" onclick="LogClickCount(this,336);">Cassandra</a>
<a title="CloudStack" href="http://www.csdn.net/tag/cloudstack" target="_blank" onclick="LogClickCount(this,336);">CloudStack</a>
<a title="FTC" href="http://www.csdn.net/tag/ftc" target="_blank" onclick="LogClickCount(this,336);">FTC</a>
<a title="coremail" href="http://www.csdn.net/tag/coremail" target="_blank" onclick="LogClickCount(this,336);">coremail</a>
<a title="OPhone " href="http://www.csdn.net/tag/ophone" target="_blank" onclick="LogClickCount(this,336);">OPhone </a>
<a title="CouchBase" href="http://www.csdn.net/tag/couchbase" target="_blank" onclick="LogClickCount(this,336);">CouchBase</a>
<a title="云计算" href="http://www.csdn.net/tag/%E4%BA%91%E8%AE%A1%E7%AE%97" target="_blank" onclick="LogClickCount(this,336);">云计算</a>
<a title="iOS6" href="http://www.csdn.net/tag/iOS6" target="_blank" onclick="LogClickCount(this,336);">iOS6</a>
<a title="Rackspace " href="http://www.csdn.net/tag/rackspace" target="_blank" onclick="LogClickCount(this,336);">Rackspace </a>
<a title="Web App" href="http://www.csdn.net/tag/webapp" target="_blank" onclick="LogClickCount(this,336);">Web App</a>
<a title="SpringSide" href="http://www.csdn.net/tag/springside" target="_blank" onclick="LogClickCount(this,336);">SpringSide</a>
<a title="Maemo" href="http://www.csdn.net/tag/maemo" target="_blank" onclick="LogClickCount(this,336);">Maemo</a>
<a title="Compuware" href="http://www.csdn.net/tag/compuware" target="_blank" onclick="LogClickCount(this,336);">Compuware</a>
<a title="大数据" href="http://www.csdn.net/tag/%E5%A4%A7%E6%95%B0%E6%8D%AE" target="_blank" onclick="LogClickCount(this,336);">大数据</a>
<a title="aptech" href="http://www.csdn.net/tag/aptech" target="_blank" onclick="LogClickCount(this,336);">aptech</a>
<a title="Perl" href="http://www.csdn.net/tag/perl" target="_blank" onclick="LogClickCount(this,336);">Perl</a>
<a title="Tornado" href="http://www.csdn.net/tag/tornado" target="_blank" onclick="LogClickCount(this,336);">Tornado</a>
<a title="Ruby" href="http://www.csdn.net/tag/ruby" target="_blank" onclick="LogClickCount(this,336);">Ruby</a>
<a title="Hibernate" href="http://www.csdn.net/hibernate" target="_blank" onclick="LogClickCount(this,336);">Hibernate</a>
<a title="ThinkPHP" href="http://www.csdn.net/tag/thinkphp" target="_blank" onclick="LogClickCount(this,336);">ThinkPHP</a>
<a title="Spark" href="http://www.csdn.net/tag/spark" target="_blank" onclick="LogClickCount(this,336);">Spark</a>
<a title="HBase" href="http://www.csdn.net/tag/hbase" target="_blank" onclick="LogClickCount(this,336);">HBase</a>
<a title="Pure" href="http://www.csdn.net/tag/pure" target="_blank" onclick="LogClickCount(this,336);">Pure</a>
<a title="Solr" href="http://www.csdn.net/tag/solr" target="_blank" onclick="LogClickCount(this,336);">Solr</a>
<a title="Angular" href="http://www.csdn.net/tag/angular" target="_blank" onclick="LogClickCount(this,336);">Angular</a>
<a title="Cloud Foundry" href="http://www.csdn.net/tag/cloudfoundry" target="_blank" onclick="LogClickCount(this,336);">Cloud Foundry</a>
<a title="Redis" href="http://www.csdn.net/tag/redis" target="_blank" onclick="LogClickCount(this,336);">Redis</a>
<a title="Scala" href="http://www.csdn.net/tag/scala" target="_blank" onclick="LogClickCount(this,336);">Scala</a>
<a title="Django" href="http://www.csdn.net/tag/django" target="_blank" onclick="LogClickCount(this,336);">Django</a>
<a title="Bootstrap" href="http://www.csdn.net/tag/bootstrap" target="_blank" onclick="LogClickCount(this,336);">Bootstrap</a>
    </div>
</div>

                    <div class="clear">
                    </div>
                </div>
            </div>
            <div id="side">
    <div class="side">
<div id="panel_Profile" class="panel">
<ul class="panel_head"><span>个人资料</span></ul>
<ul class="panel_body profile">
<div id="blog_userface">
    <a href="http://my.csdn.net/v_JULY_v" target="_blank">
    <img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/1_v_july_v.jpg" title="访问我的空间" style="max-width:90%">
    </a>
    <br>
    <span><a href="http://my.csdn.net/v_JULY_v" class="user_name" target="_blank">v_JULY_v</a></span>
</div>
<div class="interact">
<a href="javascript:void(0);" class="attent" id="span_add_follow" title="[加关注]" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_guanzhu'])"></a>
<a href="javascript:void(0);" class="letter" onclick="loginto(1)" title="[发私信]"></a>
</div>
<div id="blog_medal">
        <div class="ico_expert" title="CSDN认证专家"></div>
<div id="bms_box"><a href="http://medal.blog.csdn.net/allmedal.aspx" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/mvp_s.gif" onmouseover="m_over_m(this,0)" onmouseout="m_out_m()" alt=""></a><a href="http://medal.blog.csdn.net/allmedal.aspx" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/columnstar_s.gif" onmouseover="m_over_m(this,1)" onmouseout="m_out_m()" alt=""></a><a href="http://medal.blog.csdn.net/allmedal.aspx" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/holdon_s2.gif" onmouseover="m_over_m(this,2)" onmouseout="m_out_m()" alt=""></a></div></div>
<ul id="blog_rank">
    <li>访问：<span>6375954次</span></li>
    <li>积分：<span>30528分</span></li>
    <li>排名：<span>第47名</span></li>
</ul>
<ul id="blog_statistics">
    <li>原创：<span>145篇</span></li>
    <li>转载：<span>0篇</span></li>
    <li>译文：<span>5篇</span></li>
    <li>评论：<span>11951条</span></li>
</ul>
</ul>
</div>


<div id="custom_column_3628263" class="panel">
<ul class="panel_head"><span>博客公告</span></ul>
<ul class="panel_body">
①.本blog开通于2010年10月11日，高级C++/算法交流群： 165229498。②.Google或百度上搜索：“结构之法”，进入本博客；Github上搜：“程序员编程艺术”，进入我的github主页<a href="https://github.com/julycoding/The-Art-Of-Programming-By-July" target="_blank">https://github.com/julycoding/The-Art-Of-Programming-By-July</a>。③.如有任何问题，欢迎通过微博联系，即@研究者July：<a href="http://weibo.com/julyweibo" target="_blank">http://weibo.com/julyweibo</a>，邮箱：zhoulei97@aliyun.com，July，二零一三年八月七日。
</ul>
</div><div id="custom_column_1006267" class="panel">
<ul class="panel_head"><span>我的微博</span></ul>
<ul class="panel_body">
<iframe class="share_self" scrolling="no" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/index.htm" frameborder="0" height="350" width="100%"></iframe>
</ul>
</div><div id="panel_Category" class="panel">
<ul class="panel_head"><span>文章分类</span></ul>
<ul class="panel_body">
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/795430" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">03.Algorithms（实现）</a><span>(9)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/769275" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">01.Algorithms（研究）</a><span>(27)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/772685" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">02.Algorithms（后续）</a><span>(22)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/795592" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">04.Algorithms（讨论）</a><span>(1)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/767340" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">05.MS 100' original</a><span>(7)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/767341" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">06.MS 100' answers</a><span>(13)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/767339" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">07.MS 100' classify</a><span>(4)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/772664" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">08.MS 100' one Keys</a><span>(6)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/807763" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">09.MS 100' follow-up</a><span>(4)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/767342" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">10.MS 100' comments</a><span>(4)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/784066" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">11.TAOPP（编程艺术）</a><span>(34)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/823515" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">12.TAOPP string</a><span>(8)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/823516" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">13.TAOPP array</a><span>(14)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/823988" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">14.TAOPP list</a><span>(2)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/823993" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">15.stack/heap/queue</a><span>(0)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/823989" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">16.TAOPP tree</a><span>(2)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/823990" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">17.TAOPP c/c++</a><span>(2)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/823517" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">18.TAOPP function</a><span>(2)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/823518" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">19.TAOPP algorithms</a><span>(8)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/824851" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">20.number operations</a><span>(1)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/835511" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">21.Essays</a><span>(9)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/1106578" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">22.Big Data Processing</a><span>(5)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/1112658" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">23.Redis/MongoDB</a><span>(0)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/771597" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">24.data structures</a><span>(12)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/774945" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">25.Red-black tree</a><span>(7)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/792352" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">26.Image Processing</a><span>(3)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/854240" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">27.Architecture design</a><span>(4)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/865324" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">28.Source analysis</a><span>(3)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/896844" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">29.Recommend&amp;Search</a><span>(4)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/v_july_v/article/category/1061301" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">30.Machine L&amp;Data Mining</a><span>(5)</span>
            </li>
</ul>
</div><div id="panel_Category" class="panel">
    <ul class="panel_head"><span>博客专栏</span></ul>
    <ul class="panel_body" id="sp_column">
    <table cellpadding="0" cellspacing="0"><tbody><tr>
    <td style="padding:10px 10px 0 0;">
    <a href="http://blog.csdn.net/column/details/datamining.html" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/20130709094606406.jpg" style="width:75px;height:75px;"></a>
    </td>
    <td style="padding:10px 0; vertical-align:top;">
    <a href="http://blog.csdn.net/column/details/datamining.html" target="_blank">数据挖掘十大算法系列</a>
    <p>文章：5篇</p>
    <span>阅读：441996</span>
    </td>
    </tr></tbody></table>
    <table cellpadding="0" cellspacing="0"><tbody><tr>
    <td style="padding:10px 10px 0 0;">
    <a href="http://blog.csdn.net/column/details/ms100.html" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/20120319110713561.jpg" style="width:75px;height:75px;"></a>
    </td>
    <td style="padding:10px 0; vertical-align:top;">
    <a href="http://blog.csdn.net/column/details/ms100.html" target="_blank">微软面试100题系列</a>
    <p>文章：18篇</p>
    <span>阅读：1884192</span>
    </td>
    </tr></tbody></table>
    <table cellpadding="0" cellspacing="0"><tbody><tr>
    <td style="padding:10px 10px 0 0;">
    <a href="http://blog.csdn.net/column/details/taopp.html" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/20120319123739688.jpg" style="width:75px;height:75px;"></a>
    </td>
    <td style="padding:10px 0; vertical-align:top;">
    <a href="http://blog.csdn.net/column/details/taopp.html" target="_blank">程序员编程艺术</a>
    <p>文章：32篇</p>
    <span>阅读：1410307</span>
    </td>
    </tr></tbody></table>
    <table cellpadding="0" cellspacing="0"><tbody><tr>
    <td style="padding:10px 10px 0 0;">
    <a href="http://blog.csdn.net/column/details/Dijkstra.html" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/20120316111238277.jpg" style="width:75px;height:75px;"></a>
    </td>
    <td style="padding:10px 0; vertical-align:top;">
    <a href="http://blog.csdn.net/column/details/Dijkstra.html" target="_blank">经典算法研究</a>
    <p>文章：32篇</p>
    <span>阅读：1650923</span>
    </td>
    </tr></tbody></table>
    </ul>
</div><div class="panel" id="panel_Search">
    <ul class="panel_head"><span>文章搜索</span></ul>
    <ul class="panel_body">
        <form id="frmSearch" action="http://so.csdn.net/search" class="form_search" target="_blank">
        <span><input id="inputSearch" class="blogsearch" title="请输入关键字" type="text"></span>
        <input id="btnSubmit" value="搜索" title="search in blog" type="submit">
        <input name="q" id="inputQ" type="hidden">
        <input name="t" value="blog" type="hidden">
        <a id="btnSearchBlog" target="_blank"></a>
        </form>
    </ul>
</div><div id="hotarticls" class="panel">
<ul class="panel_head">
    <span>       
阅读排行    </span>
</ul>

<ul class="panel_body itemlist">
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/6543438" title="程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦">程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦</a><span>(296514)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/7382693" title="教你如何迅速秒杀掉：99%的海量数据处理面试题">教你如何迅速秒杀掉：99%的海量数据处理面试题</a><span>(250079)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/7974418" title="九月十月百度人搜，阿里巴巴，腾讯华为笔试面试八十题(第331-410题)">九月十月百度人搜，阿里巴巴，腾讯华为笔试面试八十题(第331-410题)</a><span>(201291)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/6530142" title="从B树、B+树、B*树谈到R 树">从B树、B+树、B*树谈到R 树</a><span>(189830)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/7624837" title="支持向量机通俗导论（理解SVM的三层境界）">支持向量机通俗导论（理解SVM的三层境界）</a><span>(186540)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/6015165" title="横空出世，席卷互联网--评微软等公司数据结构+算法面试100题">横空出世，席卷互联网--评微软等公司数据结构+算法面试100题</a><span>(160848)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/6279498" title="十道海量数据处理面试题与十个方法大总结">十道海量数据处理面试题与十个方法大总结</a><span>(151774)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/6256463" title="十一、从头到尾彻底解析Hash表算法">十一、从头到尾彻底解析Hash表算法</a><span>(126442)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/6057286" title="微软公司等数据结构+算法面试100题(第1-100题)全部出炉">微软公司等数据结构+算法面试100题(第1-100题)全部出炉</a><span>(109493)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/6105630" title="教你透彻了解红黑树">教你透彻了解红黑树</a><span>(108833)</span>
</li>
</ul>
</div>
<div id="hotarticls2" class="panel">
<ul class="panel_head"><span>评论排行</span></ul>
<ul class="panel_body itemlist">
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/6543438" title="程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦">程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦</a><span>(449)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/7974418" title="九月十月百度人搜，阿里巴巴，腾讯华为笔试面试八十题(第331-410题)">九月十月百度人搜，阿里巴巴，腾讯华为笔试面试八十题(第331-410题)</a><span>(378)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/6803368" title="九月腾讯，创新工场，淘宝等公司最新面试三十题（第171-200题）">九月腾讯，创新工场，淘宝等公司最新面试三十题（第171-200题）</a><span>(346)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/6228235" title="当今世界最为经典的十大算法--投票进行时">当今世界最为经典的十大算法--投票进行时</a><span>(323)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/7624837" title="支持向量机通俗导论（理解SVM的三层境界）">支持向量机通俗导论（理解SVM的三层境界）</a><span>(317)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/6530142" title="从B树、B+树、B*树谈到R 树">从B树、B+树、B*树谈到R 树</a><span>(312)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/6015165" title="横空出世，席卷互联网--评微软等公司数据结构+算法面试100题">横空出世，席卷互联网--评微软等公司数据结构+算法面试100题</a><span>(277)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/6628086" title="我的大学生涯">我的大学生涯</a><span>(266)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/6322882" title="程序员编程艺术：第一章、左旋转字符串">程序员编程艺术：第一章、左旋转字符串</a><span>(247)</span>
</li>
<li>
<a href="http://blog.csdn.net/v_july_v/article/details/7382693" title="教你如何迅速秒杀掉：99%的海量数据处理面试题">教你如何迅速秒杀掉：99%的海量数据处理面试题</a><span>(246)</span>
</li>
</ul>
</div>
<div id="newcomments" class="panel">
<ul class="panel_head"><span>最新评论</span></ul>
<ul class="panel_body itemlist">
    <li>
    <a href="http://blog.csdn.net/v_JULY_v/article/details/6704077#comments">从Hadoop框架与MapReduce模式中谈海量数据处理（含淘宝技术架构）</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/yaerfeng" class="user_name">yaerfeng</a>:
hadoop代码下载：http://www.zuidaima.com/share/search.ht...
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/v_JULY_v/article/details/6555899#comments">第九章三续：SIFT算法的应用--目标识别之Bag-of-words模型</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/cjc211322" class="user_name">cjc雪狼</a>:
给力
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/v_JULY_v/article/details/6096981#comments">经典算法研究系列：二、Dijkstra 算法初探</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/twwwwwy" class="user_name">囧思</a>:
弱弱地问下，第一个图 AC + BC &lt; AB，这个三角形是不是有些问题？还是因为其他的原因所以可以...
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/v_JULY_v/article/details/6403777#comments">程序员编程艺术：第三章续、Top K算法问题的实现</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/xintao901029" class="user_name">xintao901029</a>:
@sunqk13022:先跟左孩子选择较小的，然后跟右孩子再选择更小，两个比较后就是三者中最小了，没...
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/v_JULY_v/article/details/7624837#comments">支持向量机通俗导论（理解SVM的三层境界）</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/econsh" class="user_name">econsh</a>:
这在直观上也不难理解，最大值中最小的一个总也比最小值中最大的一个要大吧！这个不明白啊，假设有两组值【...
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/v_JULY_v/article/details/6441279#comments">程序员编程艺术：第六章、求解500万以内的亲和数</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/oMuYeJingFeng1" class="user_name">SHAOIT</a>:
@oMuYeJingFeng1:长知识了
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/v_JULY_v/article/details/6441279#comments">程序员编程艺术：第六章、求解500万以内的亲和数</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/oMuYeJingFeng1" class="user_name">SHAOIT</a>:
那道亲和力的程序 很赞数组可以那么用，不知识了
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/v_JULY_v/article/details/6444021#comments">程序员编程艺术：第七章、求连续子数组的最大和</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/SisMVG" class="user_name">四元飒</a>:
在sum-=val前少打了的：int temp=sum;if(sum&lt;temp)sum=temp;
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/v_JULY_v/article/details/6444021#comments">程序员编程艺术：第七章、求连续子数组的最大和</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/SisMVG" class="user_name">四元飒</a>:
我的做法：计算一次保存和从数组两端同时遍历数组，小的端缩短并且减去，相等则向左（其实随便啦）int ...
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/v_JULY_v/article/details/6417600#comments">程序员编程艺术：第四章、现场编写类似strstr/strcpy/strpbrk的函数</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/oMuYeJingFeng1" class="user_name">SHAOIT</a>:
LZ 先膜拜你一下：我仔细看你你写 的strstr 和库函数的复杂度都为o(m*n) 我自己也写了一...
    </p>
    </li>
</ul>
</div>
<div id="custom_column_1006263" class="panel">
<ul class="panel_head"><span>01、本blog索引</span></ul>
<ul class="panel_body">
<ul><li><a href="http://bbs.csdn.net/topics/350187239" target="_blank">3、微软100题维护地址</a></li><li><a href="http://blog.csdn.net/v_JULY_v/archive/2010/11/17/6015165.aspx" target="_blank">1、微软100题横空出世</a></li><li><a href="http://blog.csdn.net/v_JULY_v/category/769275.aspx" target="_blank">5、经典算法研究系列</a></li><li><a href="http://blog.csdn.net/v_JULY_v/category/774945.aspx" target="_blank">7、红黑树系列集锦</a></li><li><a href="http://blog.csdn.net/v_JULY_v/category/784066.aspx" target="_blank">6、程序员编程艺术系列</a></li><li><a href="http://blog.csdn.net/v_JULY_v/archive/2010/12/06/6057286.aspx" target="_blank">2、微软面试全部100题</a></li><li><a href="http://blog.csdn.net/v_JULY_v/archive/2011/06/14/6543438.aspx" target="_blank">0、经典5大原创系列集锦</a></li><li><a href="http://v_july_v.download.csdn.net/" target="_blank">4、微软100题下载地址</a></li></ul>
</ul>
</div><div id="custom_column_1006264" class="panel">
<ul class="panel_head"><span>02、Google or baidu?</span></ul>
<ul class="panel_body">
<ul><li><a href="http://www.google.com.hk/webhp?hl=zh-CN#hl=zh-CN&amp;safe=strict&amp;rlz=1R2GGHP_zh-CNCN437&amp;biw=1131&amp;bih=694&amp;q=%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95&amp;oq=&amp;aq=&amp;aqi=&amp;aql=&amp;gs_sm=&amp;gs_upl=&amp;rlz=1R2GGHP_zh-CNCN437&amp;fp=51c0" target="_blank">Google搜--"结构之法"（My BLOG）</a></li><li><a href="http://www.baidu.com/s?bs=%BD%E1%B9%B9%D6%AE%B7%A8&amp;f=8&amp;wd=%BD%E1%B9%B9%D6%AE%B7%A8&amp;inputT=3625" target="_blank">baidu 搜--"结构之法"（My BLOG）</a></li></ul>
</ul>
</div><div id="custom_column_1006266" class="panel">
<ul class="panel_head"><span>03、我的驻点</span></ul>
<ul class="panel_body">
<ul>
<li><a href="http://weibo.com/julyweibo" target="_blank">01. 我的新浪微博</a></li>
<ul>
<li><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July" target="_blank">02. 我的Github主页</a></li>
<li><a href="http://zhedahht.blog.163.com/blog/#m=0" target="_blank">03、Harry</a></li>
<li><a href="http://blog.nosqlfan.com/" target="_blank">04、NoSQLFan</a></li>
<li><a href="http://www.kuqin.com//" target="_blank">04、酷勤网</a></li>
<li><a href="http://www.52nlp.cn/" target="_blank">05、52nlp</a></li>
<li><a href="http://www.itmian4.com/" target="_blank">06、IT面试论坛</a></li>
<li><a href="http://blog.csdn.net/yangliuy" target="_blank">07、北大朋友的挖掘乐园</a></li>
<li><a href="http://blog.csdn.net/abcjennifer" target="_blank">08、跟Sophia_qing一起读硕士</a></li>
<li><a href="http://blog.csdn.net/caopengcs" target="_blank">08、caopengcs</a></li>
<li><a href="http://www.51nod.com/focus.html" target="_blank">09、面试问答社区51nod</a></li>
<li><a href="http://blog.sina.com.cn/twocold" target="_blank">10、韩寒</a></li>
<li><a href="http://blog.sina.com.cn/shitou009" target="_blank">11、曾经的叛逆与年少</a></li>
<li><a href="http://www.cnblogs.com/daizhj/category/260889.html" "="" target="_blank">12、老D之MongoDB源码分析</a></li>
<li><a href="http://code4app.com/" target="_blank">14、code4app:iOS代码示例</a></li>
<li><a href="http://v.163.com/special/opencourse/machinelearning.html" target="_blank">17、斯坦福机器学习公开课</a></li>
<li><a href="http://preshing.com/" target="_blank">19、Memory Model与并发编程</a></li>
<li><a href="http://www.dewen.org/" target="_blank">20、德问--编程是一种艺术创作</a></li>
<li><a href="http://stblog.baidu-tech.com/" target="_blank">22、百度搜索研发部</a></li>
<li><a href="http://www.searchtb.com/" target="_blank">23、淘宝搜索技术博客</a></li>
<li><a href="https://www.interviewstreet.com/challenges/" target="_blank">24、interviewstreet</a></li>
<li><a href="http://leetcode.com/" target="_blank">25、LeetCode</a></li>
<li><a href="http://xiaozu.renren.com/xiaozu/245753?feed" target="_blank">26、Team_Algorithms人人小组</a></li>
</ul></ul>
</ul>
</div><div id="panel_Archive" class="panel">
<ul class="panel_head"><span>文章存档</span></ul>
<ul class="panel_body">
<div id="archive_list"><li><a href="http://blog.csdn.net/v_july_v/article/month/2014/02">2014年02月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2014/01">2014年01月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2013/12">2013年12月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2013/09">2013年09月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2013/08">2013年08月</a><span>(2)</span></li><span class="hidelist" style="display:none;"><li><a href="http://blog.csdn.net/v_july_v/article/month/2013/06">2013年06月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2013/03">2013年03月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2012/12">2012年12月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2012/11">2012年11月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2012/09">2012年09月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2012/06">2012年06月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2012/05">2012年05月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2012/04">2012年04月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2012/03">2012年03月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2012/02">2012年02月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2012/01">2012年01月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2011/12">2011年12月</a><span>(5)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2011/11">2011年11月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2011/10">2011年10月</a><span>(7)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2011/09">2011年09月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2011/08">2011年08月</a><span>(11)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2011/07">2011年07月</a><span>(4)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2011/06">2011年06月</a><span>(7)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2011/05">2011年05月</a><span>(10)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2011/04">2011年04月</a><span>(7)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2011/03">2011年03月</a><span>(17)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2011/02">2011年02月</a><span>(11)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2011/01">2011年01月</a><span>(18)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2010/12">2010年12月</a><span>(14)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2010/11">2010年11月</a><span>(6)</span></li><li><a href="http://blog.csdn.net/v_july_v/article/month/2010/10">2010年10月</a><span>(5)</span></li></span><div id="archive_list_button" class="list_closed">展开</div></div>
</ul>
</div>
    </div>
    <div class="clear">
    </div>
</div>

            <div class="clear">
            </div>
        </div>
        

<script type="text/javascript" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/newblog.js"></script>
<script type="text/javascript" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/showblogmedal.js"></script>
<script type="text/javascript">
    document.write('<script type="text/javascript" src="http://csdnimg.cn/pubfooter/js/publib_footer.js?' + Math.floor(new Date() / 120000).toString(36) + '="></' + 'script>');
</script><script type="text/javascript" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/publib_footer.js"></script><link rel="stylesheet" type="text/css" href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/pub_footer_2012.css"><div id="pub_footerall" class="pub_footerall"><dl><dt></dt> <dd><a href="http://www.csdn.net/company/about.html" target="_blank">公司简介</a>|<a href="http://www.csdn.net/company/recruit.html" target="_blank">招贤纳士</a>|<a href="http://www.csdn.net/company/marketing.html" target="_blank">广告服务</a>|<a href="http://www.csdn.net/company/account.html" target="_blank">银行汇款帐号</a>|<a href="http://www.csdn.net/company/contact.html" target="_blank">联系方式</a>|<a href="http://www.csdn.net/company/statement.html" target="_blank">版权声明</a>|<a href="http://www.csdn.net/company/layer.html" target="_blank">法律顾问</a>|<a href="mailto:webmaster@csdn.net">问题报告</a>|<a target="_blank" href="http://www.csdn.net/friendlink.html">合作伙伴</a>|<a href="http://bbs.csdn.net/forums/Service" target="_blank">论坛反馈</a></dd><dd><a href="http://wpa.qq.com/msgrd?v=3&amp;uin=2355263776&amp;site=qq&amp;menu=yes" target="_blank" class="qq">网站客服</a> <a href="http://wpa.qq.com/msgrd?v=3&amp;uin=2251809102&amp;site=qq&amp;menu=yes" target="_blank" class="qq">杂志客服</a> <a href="http://e.weibo.com/csdnsupport/profile" target="_blank" class="weibo">微博客服</a> <a href="mailto:webmaster@csdn.net" class="email" title="联系邮箱">webmaster@csdn.net</a> <span class="phone" title="服务热线">400-600-2320</span></dd><dd>京&nbsp;ICP&nbsp;证&nbsp;070598&nbsp;号</dd><dd>北京创新乐知信息技术有限公司 版权所有</dd><dd>江苏乐知网络技术有限公司 提供商务支持</dd><dd>Copyright © 1999-2014, CSDN.NET, All Rights Reserved&nbsp;<a href="http://www.hd315.gov.cn/beian/view.asp?bianhao=010202001032100010" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/gongshang_logos.gif" alt="GongshangLogo" title=""></a></dd></dl></div><div id="note1" class="csdn_note" style="display:none; position:absolute; z-index:9999; width:440px">  <span class="notice_top_arrow"><span class="inner"></span></span>  <div class="box"></div></div><div class="csdn_notice_tip" style="display:none; position:absolute; z-index:9990; width:170px">  <iframe src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/a_002.htm" scrolling="no" style="z-index:-1;position:absolute;top:0;left:0;width:100%;height:100%;background:transparent" frameborder="0"></iframe>  <div class="tip_text">您有<strong>0</strong>条新通知</div>  <a href="javascript:void%200" class="close2"></a></div><script id="noticeScript" type="text/javascript" btnid="header_notice_num" wrapid="note1" count="5" subcount="5" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/notify.js"></script>
    <script type="text/javascript" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/login.js"></script>
    <script type="text/javascript" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/tongji.js"></script><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/tongji.gif" border="0" height="1" width="1"><a href="http://tongji.linezing.com/report.html?unit_id=2671462" target="_blank"><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/stats.gif" alt="量子统计" border="0"></a>
<script type="text/javascript">document.write("<img src=http://counter.csdn.net/pv.aspx?id=24 border=0 width=0 height=0>");</script><img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/pv.xml" border="0" height="0" width="0">
<script type="text/javascript" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/counter.js"></script><script type="text/javascript" charset="UTF-8" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/msg.js"></script>
<script type="text/javascript" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ad-blog.js"></script><script type="text/javascript" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/ad-ms774.js"></script>

<script type="text/javascript" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/count.js"></script><iframe src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/logs.htm" frameborder="0" height="0" width="0"></iframe>
<script type="text/javascript">
    $(function () {
        function __get_code_toolbar(snippet_id) {
            return $("<a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "' target='_blank' title='在CODE上查看代码片' style='text-indent:0;'><img src='https://code.csdn.net/assets/CODE_ico.png' width=12 height=12 alt='在CODE上查看代码片' style='position:relative;top:1px;left:2px;'/></a>"
                    + "<a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "/fork' target='_blank' title='派生到我的代码片'  style='text-indent:0;'><img src='https://code.csdn.net/assets/ico_fork.svg' width=12 height=12 alt='派生到我的代码片' style='position:relative;top:2px;left:2px;'/></a>");
        }
        
        $("[code_snippet_id]").each(function () {
            __s_id = $(this).attr("code_snippet_id");
            if (__s_id != null && __s_id != "" && __s_id != 0 && parseInt(__s_id) > 70020) {
                __code_tool = __get_code_toolbar(__s_id);
                $(this).prev().find(".tools").append(__code_tool);
            }
        });
    });
</script>

    </div>
      <!--new top-->
    
    <script id="csdn-toolbar-id" btnid="header_notice_num" wrapid="note1" count="5" subcount="5" type="text/javascript" src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/toolbar.js"></script>
     <!--new top-->


<iframe src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET_files/log.swf" style="width: 1px; height: 1px; position: absolute; visibility: hidden;"></iframe></body></html>